{"ast":null,"code":"var _jsxFileName = \"/Users/sarah/Documents/Sarah/Projects/reu/covid19-forecasting-market/frontend/src/components/UserPredictionChart/index.js\";\nimport React, { Component } from 'react';\nimport * as d3 from 'd3';\nimport './UserPredictionChart.css';\n\nclass UserPredictionChart extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      category: \"us_daily_deaths\"\n    };\n    this.chartRef = React.createRef();\n  }\n\n  componentDidMount() {\n    //console.log(this.props);\n    this.renderChart();\n  }\n\n  renderChart() {\n    const {\n      forecast,\n      orgs,\n      userPrediction,\n      confirmed,\n      aggregate\n    } = this.props;\n    var predictionData = []; //where we will store formatted userPrediction\n\n    var defaultPredictionData = [];\n    const savePrediction = this.savePrediction;\n    const createDefaultPrediction = this.createDefaultPrediction;\n    const category = this.state.category;\n    var compiledData = []; //set up margin, width, height of chart\n\n    const legendWidth = 180;\n    const toolTipHeight = 50; //to make sure there's room for the tooltip when the value is 0\n\n    const contextHeight = 100;\n    var margin = {\n      top: 20,\n      right: 30,\n      bottom: 20,\n      left: 60\n    },\n        width = 800 - margin.left - margin.right,\n        height = 400 - margin.top - margin.bottom;\n    var svg = d3.select(this.chartRef.current).append(\"svg\").attr(\"width\", width + margin.left + margin.right + legendWidth).attr(\"height\", height + margin.top + margin.bottom + toolTipHeight + contextHeight).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\"); //format confirmedData, forecastData, and predictionData into a list of js objects, convert date from string to js date object\n\n    var confirmedData = Object.keys(confirmed).map(key => ({\n      date: d3.timeParse(\"%Y-%m-%d\")(key),\n      value: confirmed[key]\n    })); //store userPrediction in predictionData if it exists\n\n    if (Object.keys(userPrediction).length > 0) {\n      predictionData = getMostRecentPrediction(userPrediction).map(p => ({\n        date: d3.timeParse(\"%Y-%m-%d\")(p.date.substring(0, 10)),\n        value: p.value,\n        defined: p.defined\n      }));\n    }\n\n    console.log(predictionData); //set other dates\n\n    const confirmedStartDate = d3.timeParse(\"%Y-%m-%d\")(\"2020-02-01\"); //date format: y-m-d\n\n    const predStartDate = confirmedData[confirmedData.length - 1].date; //last date of confirmedData\n\n    const predLength = 155; //var predEndDateString = addDays(new Date(), predLength).toISOString().substring(0, 10);\n\n    const predEndDate = d3.timeDay.offset(predStartDate, predLength); //get confirmedData starting from confirmedStartDate\n\n    confirmedData = confirmedData.filter(d => +d.date >= +confirmedStartDate); //draw x-axis     \n\n    var x = d3.scaleTime().domain([confirmedStartDate, predEndDate]).range([0, width]); //.nice(); //rounds up/down the max and mind of x axis\n\n    var xAxis = svg.append(\"g\").attr(\"transform\", \"translate(0,\" + height + \")\").call(d3.axisBottom(x)); //find max val in confirmedData and forecastData to determine the max of y-axis\n\n    var confirmedMax = d3.max(confirmedData, function (d) {\n      return +d.value;\n    });\n    var forecastMax = 0;\n    forecastData.map(f => {\n      var currMax = d3.max(f, d => {\n        return d.value;\n      });\n      forecastMax = currMax > forecastMax ? currMax : forecastMax;\n    });\n    var yAxisMax = Math.max(confirmedMax, forecastMax); //draw y-axis\n\n    var y = d3.scaleLinear().domain([0, yAxisMax]).range([height, 0]).nice();\n    svg.append(\"g\").call(d3.axisLeft(y)); //list of data displayed in graph - for legend\n\n    var legendString = orgs.concat([\"Daily Confirmed Deaths\", \"Aggregate Forecast\", \"User Prediction\"]); //color function that assigns random colors to each data\n\n    var color = d3.scaleOrdinal().domain(legendString).range(d3.schemeTableau10); //draw legend\n\n    var legend = svg.append('g').attr(\"id\", \"legend\");\n    var size = 10;\n    legend.selectAll(\"rect\").data(legendString).enter().append(\"circle\").attr('cx', width + 30).attr(\"cy\", function (d, i) {\n      return 20 + i * 25;\n    }) // 100 is where the first dot appears. 25 is the distance between dots\n    .attr(\"r\", 6) //.attr(\"width\", size)\n    //.attr(\"height\", size)\n    .style(\"fill\", function (d) {\n      return color(d);\n    });\n    legend.selectAll(\"labels\").data(legendString).enter().append(\"text\").attr(\"x\", width + 45).attr(\"y\", function (d, i) {\n      return 20 + i * 25;\n    }) // 100 is where the first dot appears. 25 is the distance between dots\n    .style(\"fill\", function (d) {\n      return color(d);\n    }).text(function (d) {\n      return d;\n    }).attr(\"text-anchor\", \"left\").style(\"alignment-baseline\", \"middle\"); //create line generator for confirmed/forecast data and prediction data\n\n    var lineGenerator = d3.line().curve(d3.curveBasis); //.curve(d3.curveCatmullRom)//curve that goes through all data points\n\n    var predLineGenerator = d3.line().curve(d3.curveBasis); //curve doesn't go through all data points (it's smoothed out)\n    //d3.curveMonotoneX\n    //d3.curveBasis\n    //d3.curveCardinal\n    //function that draws curve\n\n    var line = lineGenerator.x(function (d) {\n      return x(d.date);\n    }).y(function (d) {\n      return y(d.value);\n    }); //area where the confirmed curve will be drawn\n\n    var mainClip = svg.append(\"defs\").append(\"svg:clipPath\").attr(\"id\", \"main-clip\").append(\"svg:rect\").attr(\"width\", width).attr(\"height\", height).attr(\"x\", 0).attr(\"y\", 0); // Create the confirmed area variable\n\n    const mainArea = svg.append('g').attr(\"clip-path\", \"url(#main-clip)\"); //display confirmed data\n\n    var confirmedLine = mainArea.append(\"path\").attr(\"id\", \"confirmed\").attr(\"class\", \"line\").datum(confirmedData).attr('d', line).attr(\"stroke\", color(legendString[legendString.length - 3]));\n    var confirmedAreaEndX = x(confirmedData[confirmedData.length - 1].date);\n    var confirmedAreaEndY = y(confirmedData[confirmedData.length - 1].value); //append clip-path for prediction curve\n\n    var predictionClip = svg.append(\"defs\").append(\"svg:clipPath\").attr(\"id\", \"prediction-clip\").append(\"svg:rect\").attr(\"width\", width - confirmedAreaEndX).attr(\"height\", height).attr(\"x\", confirmedAreaEndX).attr(\"y\", 0);\n    const predictionArea = svg.append('g').attr(\"clip-path\", \"url(#prediction-clip)\"); //make sure aggregateData curve stems from confiremData curve\n\n    var idxOfStartDate = d3.bisector(f => f.date).left(aggregateData, predStartDate); //check if predStartDate exists in AD\n\n    if (aggregateData.length > 0 && +aggregateData[idxOfStartDate].date == +predStartDate) {\n      aggregateData[idxOfStartDate].value = confirmedData[confirmedData.length - 1].value;\n    } else {\n      aggregateData.splice(idxOfStartDate, 0, {\n        date: predStartDate,\n        value: confirmedData[confirmedData.length - 1].value\n      });\n      console.log(aggregateData);\n      console.log(\"done\");\n    } //display aggregate data\n\n\n    var aggregateLine = predictionArea.append(\"path\").attr(\"id\", \"aggregate\").attr(\"class\", \"line\").datum(aggregateData).attr('d', line).attr(\"stroke\", color(legendString[legendString.length - 2])); //display forecast data\n\n    forecastData.map((f, index) => {\n      //make sure they all stem from the confirmed curve!\n      //var temp = d3.timeParse(\"%Y-%m-%d\")(\"2020-07-18\")\n      var idxOfStartDate = d3.bisector(f => f.date).left(f, predStartDate); //check if predStartDate exists in f\n\n      if (f.length > 0 && +f[idxOfStartDate].date == +predStartDate) {\n        f[idxOfStartDate].value = confirmedData[confirmedData.length - 1].value;\n      } else {\n        f.splice(idxOfStartDate, 0, {\n          date: predStartDate,\n          value: confirmedData[confirmedData.length - 1].value\n        });\n        console.log(f);\n        console.log(\"done\");\n      }\n\n      console.log(f);\n      console.log(idxOfStartDate);\n      predictionArea.append(\"path\").attr(\"class\", \"forecast line\").attr(\"id\", orgs[index]).style(\"stroke\", color(orgs[index])).datum(f).attr(\"d\", line);\n    });\n    var lines = document.getElementsByClassName('line'); //function that generates the prediction curve\n\n    var predLine = predLineGenerator.defined(d => d.defined).x(function (d) {\n      return x(d.date);\n    }).y(function (d) {\n      return y(d.value);\n    }); //append path for prediction data\n\n    var yourLine = predictionArea.append(\"path\").attr(\"id\", \"your-line\"); //variables used to initialize user prediction data if it doesn't exist in the db\n\n    var currDate = predStartDate;\n    var defined = true;\n    var value = confirmedData[confirmedData.length - 1].value;\n    const confirmedLastVal = value; //used to make sure the first data point of prediction stays the same\n    //check if userPrediction already exists in db\n\n    if (Object.keys(userPrediction).length > 0) {\n      predictionData = predictionData.filter(d => +d.date >= +predStartDate && +d.date <= +predEndDate);\n      predictionData[0].value = confirmedLastVal;\n      predictionData[0].defined = true;\n      currDate = d3.timeDay.offset(predictionData[predictionData.length - 1].date, 1); //currDate = addDays(predictionData[predictionData.length - 1].date, 1);\n\n      console.log(predictionData);\n      console.log(createDefaultPrediction(currDate, predEndDate));\n      predictionData.concat(createDefaultPrediction(currDate, predEndDate));\n      console.log(predictionData);\n    } else {\n      predictionData = createDefaultPrediction(predStartDate, predEndDate);\n      predictionData[0].value = confirmedLastVal;\n      predictionData[0].defined = true;\n      console.log(predictionData);\n    }\n\n    var filteredData = null; //var totalData = confirmedData.concat(predictionData);\n    //!!    //add forecast data to compiledData\n\n    orgs.map((o, index) => {\n      compiledData.push({\n        name: o,\n        data: forecastData[index]\n      });\n    });\n    compiledData.push({\n      name: \"Daily Confirmed Deaths\",\n      data: confirmedData\n    });\n    compiledData.push({\n      name: \"Aggregate Forecast\",\n      data: aggregateData\n    }); //if (userPrediction) {\n\n    compiledData.push({\n      name: \"User Prediction\",\n      data: predictionData\n    }); //}\n    //join data to yourLine\n\n    filteredData = predictionData.filter(predLine.defined());\n    yourLine.datum(filteredData).attr('d', predLine).style(\"stroke\", color(legendString[legendString.length - 1])); //append new rect  \n\n    const mouseArea = svg.append(\"rect\").attr(\"width\", width).attr(\"height\", height).attr(\"fill\", \"none\").attr(\"id\", \"mouse-area\").style(\"pointer-events\", \"visible\"); //append click area rect\n\n    var confirmedAreaWidth = confirmedLine.node().getBoundingClientRect().width; //get width of path element containing confirmed data\n\n    console.log(confirmedAreaWidth);\n    var clickAreaWidth = width - confirmedAreaWidth; //the remaining area\n\n    svg.append(\"rect\").attr(\"id\", \"click-area\").attr(\"width\", clickAreaWidth).attr(\"height\", height).attr(\"transform\", \"translate (\" + confirmedAreaWidth + \" 0)\").attr(\"fill\", \"none\").style(\"pointer-events\", \"visible\"); //var clickArea = d3.select(\"#click-area\");\n    //append draw your guess text\n\n    const drawingInstruction = svg.append(\"g\").attr(\"id\", \"drawing-instruction\").style(\"opacity\", \"0\");\n    drawingInstruction.append(\"text\").attr(\"id\", \"draw-guess\").attr(\"x\", confirmedAreaEndX + (width - confirmedAreaEndX) / 2).attr(\"y\", height - 100).attr(\"text-anchor\", \"middle\").text(\"Draw your guess\").style(\"font-size\", \"16px\"); //append circle at the end of confirmed curve\n\n    var selectCircle = drawingInstruction.append(\"g\").attr(\"id\", \"pointer\");\n    var pointerCircles = [\"pulse-disk\", \"pulse-circle\", \"pulse-circle-2\"];\n    pointerCircles.map(c => {\n      selectCircle.append(\"circle\").attr(\"class\", c).attr(\"cx\", confirmedAreaEndX).attr(\"cy\", confirmedAreaEndY);\n    });\n\n    if (Object.keys(userPrediction).length == 0) {\n      svg.select(\"#drawing-instruction\").style(\"opacity\", \"1\");\n    }\n\n    var drag = d3.drag().on(\"drag\", function () {\n      //hide \"draw your guess\" text\n      svg.select(\"#drawing-instruction\").style(\"opacity\", \"0\");\n      d3.select(\"#tooltip-line\").style(\"opacity\", \"0\");\n      d3.selectAll(\".mouse-per-line circle\").style(\"opacity\", \"0\");\n      d3.selectAll(\".mouse-per-line text\").style(\"opacity\", \"0\");\n      var pos = d3.mouse(this);\n      var date = clamp(predStartDate, predEndDate, x.invert(pos[0]));\n      var value = clamp(0, yAxisMax, y.invert(pos[1]));\n      predictionData.forEach(function (d) {\n        if (+d3.timeDay.round(d.date) == +d3.timeDay.round(date)) {\n          d.value = value;\n          d.defined = true;\n        }\n\n        predictionData[0].value = confirmedLastVal; //make sure the prediction curve is always connected to the confirmed curve\n        //update totalData everytime predictionData is updated\n\n        compiledData[compiledData.length - 1].data = predictionData; //console.log(compiledData)\n\n        /*yourLine.datum(predictionData)\n                .attr('d', predLine)*/\n\n        var filteredData = predictionData.filter(predLine.defined());\n        yourLine.datum(filteredData).attr('d', predLine).style(\"stroke\", color(legendString[legendString.length - 1]));\n      });\n    }).on(\"end\", function () {\n      savePrediction(predictionData, category);\n      d3.select(\"#tooltip-line\").style(\"opacity\", \"1\");\n      d3.selectAll(\".mouse-per-line circle\").style(\"opacity\", \"1\");\n      d3.selectAll(\".mouse-per-line text\").style(\"opacity\", \"1\");\n    });\n    svg.call(drag); //finds the datapoint closest to the mouse (along x)\n\n    /*var bisect = () => {\n        const bisectDate = d3.bisector(d => d.date).left;\n        return mx => {\n            const date = x.invert(mx);\n            const index = bisectDate(totalData, date, 1);\n            const a = totalData[index - 1];\n            const b = totalData[index];\n            return b && (date - a.date > b.date - date) ? b : a;\n        };\n    }*/\n\n    const tooltipArea = svg.append(\"g\").attr(\"class\", \"tooltip\");\n    tooltipArea.append(\"path\") //vertical line\n    .attr(\"id\", \"tooltip-line\").style(\"stroke\", \"black\").style(\"stroke-width\", \"0.5px\").style(\"opacity\", \"0\");\n    var mousePerLine = tooltipArea.selectAll(\".mouse-per-line\").data(compiledData).enter().append(\"g\").attr(\"class\", \"mouse-per-line\");\n    mousePerLine.append(\"circle\").attr(\"r\", 2).style(\"stroke\", function (d) {\n      return color(d.name);\n    }).style(\"fill\", \"none\").style(\"stroke-width\", \"1px\").style(\"opacity\", \"0\");\n    mousePerLine.append(\"text\").attr(\"transform\", \"translate(10,3)\");\n    tooltipArea.append(\"svg:rect\").attr('width', width).attr('height', height).attr('fill', 'none').attr('pointer-events', 'all').style(\"cursor\", \"pointer\").on('mouseout', function () {\n      // on mouse out hide line, circles and text\n      d3.select(\"#tooltip-line\").style(\"opacity\", \"0\");\n      d3.selectAll(\".mouse-per-line circle\").style(\"opacity\", \"0\");\n      d3.selectAll(\".mouse-per-line text\").style(\"opacity\", \"0\");\n    }).on('mouseover', function () {\n      // on mouse in show line, circles and text\n      d3.select(\"#tooltip-line\").style(\"opacity\", \"1\");\n      d3.selectAll(\".mouse-per-line circle\").style(\"opacity\", \"1\");\n      d3.selectAll(\".mouse-per-line text\").style(\"opacity\", \"1\");\n    }).on('mousemove', function () {\n      // mouse moving over canvas\n      var mouse = d3.mouse(this);\n      var xCoord = mouse[0];\n      d3.select(\"#tooltip-line\").attr(\"d\", function () {\n        var d = \"M\" + xCoord + \",\" + height;\n        d += \" \" + xCoord + \",\" + 0;\n        return d;\n      });\n      d3.selectAll(\".mouse-per-line\").attr(\"transform\", function (d, i) {\n        if (d.data.length == 0) {\n          return;\n        }\n\n        var date = x.invert(xCoord);\n        const index = d3.bisector(f => f.date).left(compiledData[i].data, date);\n        var a = null;\n\n        if (index > 0) {\n          a = d.data[index - 1];\n        }\n\n        const b = d.data[index]; //d = the data object corresponding to date and value pointed by the cursors\n\n        var data = null;\n\n        if (!a) {\n          data = b;\n        } else if (!b) {\n          data = a;\n        } else {\n          data = b && date - a.date > b.date - date ? b : a;\n        }\n\n        if (+d3.timeDay.floor(date) == +data.date || +d3.timeDay.ceil(date) == +data.date) {\n          if (data.defined != 0) {\n            var element = d3.select(this).select('text').style(\"opacity\", \"1\").text(Math.round(data.value).toFixed(2));\n            element.select(\"circle\").style(\"opacity\", \"1\");\n            return \"translate(\" + mouse[0] + \",\" + y(data.value) + \")\";\n          }\n        }\n\n        var element = d3.select(this).select(\"text\").style(\"opacity\", \"0\");\n        element.select(\"circle\").style(\"opacity\", \"0\");\n      });\n    }); /////////////////////////////////////////////////////////////////////////////////////////////\n\n    const focusHeight = 100;\n    const contextMargin = 50;\n    var context = svg.append(\"g\").attr(\"viewBox\", [0, 0, width, focusHeight]).attr(\"transform\", `translate(0,${height + contextMargin} )`) //.attr(\"width\", width + 100)\n    //.attr(\"height\", height)\n    .style(\"display\", \"block\");\n    /*const xAxis = (g, x, height) => g\n                                        .attr(\"transform\", `translate(0,${height - margin.bottom})`)\n                                        .call(d3.axisBottom(x))*/\n\n    var contextX = d3.scaleTime().domain([confirmedStartDate, predEndDate]).range([0, width]);\n    var contextXAxis = context.append(\"g\").attr(\"transform\", `translate(0,${focusHeight - margin.bottom})`).call(d3.axisBottom(contextX));\n    const brush = d3.brushX().extent([[0, 0], [width, focusHeight - margin.bottom]]).on(\"brush\", brushed).on(\"end\", brushended);\n    const defaultSelection = [x(d3.timeMonth.offset(x.domain()[1], -8)), x.range()[1]];\n    /*context.append(\"g\")\n            .call(xAxis, x, focusHeight);*/\n\n    /*svg.append(\"path\")\n        .datum(confirmedData)\n        .attr(\"fill\", \"steelblue\")\n        .attr(\"d\", line(x, y.copy().range([focusHeight - margin.bottom, 4])));*/\n\n    function brushed() {\n      console.log(\"d\");\n\n      if (d3.event.selection) {\n        var extent = d3.event.selection; //console.log([ contextX.invert(extent[0]), contextX.invert(extent[1]) ]);\n\n        x.domain([contextX.invert(extent[0]), contextX.invert(extent[1])]);\n        xAxis //.transition()\n        //.duration(1000)\n        .call(d3.axisBottom(x));\n        var newX = x(confirmedData[confirmedData.length - 1].date);\n        newX = newX < 0 ? 0 : newX;\n        console.log(newX);\n        d3.select(\"#prediction-clip\").select(\"rect\").attr(\"width\", width - newX).attr(\"x\", newX);\n        svg.selectAll(\".line\") //.transition()\n        //.duration(1000)\n        .attr('d', line);\n        svg.select(\"#your-line\").attr(\"d\", predLine); //reposition draw your guess text and pointer\n\n        svg.select(\"#draw-guess\").attr(\"x\", newX + (width - newX) / 2);\n        svg.select(\"#pointer\").selectAll(\"circle\").attr(\"cx\", newX);\n      }\n    }\n\n    function brushended() {\n      if (!d3.event.selection) {\n        gb.call(brush.move, defaultSelection);\n      }\n    }\n\n    const gb = context.call(brush).call(brush.move, defaultSelection); ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    var deleteButton = document.createElement(\"button\");\n    deleteButton.innerText = \"Reset\";\n\n    deleteButton.onclick = () => {\n      this.deletePrediction(category);\n      predictionData = createDefaultPrediction(predStartDate, predEndDate);\n      predictionData[0].value = confirmedLastVal;\n      predictionData[0].defined = true;\n      console.log(predictionData); //update yourLine\n\n      var filtered = predictionData.filter(predLine.defined());\n      console.log(filtered);\n      yourLine.datum(filtered).attr('d', predLine);\n      svg.select(\"#drawing-instruction\").style(\"opacity\", \"1\");\n    };\n\n    document.querySelector(\"body\").appendChild(deleteButton);\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: this.chartRef,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 625,\n        columnNumber: 16\n      }\n    });\n  }\n\n}\n\nexport default UserPredictionChart;","map":{"version":3,"sources":["/Users/sarah/Documents/Sarah/Projects/reu/covid19-forecasting-market/frontend/src/components/UserPredictionChart/index.js"],"names":["React","Component","d3","UserPredictionChart","constructor","props","state","category","chartRef","createRef","componentDidMount","renderChart","forecast","orgs","userPrediction","confirmed","aggregate","predictionData","defaultPredictionData","savePrediction","createDefaultPrediction","compiledData","legendWidth","toolTipHeight","contextHeight","margin","top","right","bottom","left","width","height","svg","select","current","append","attr","confirmedData","Object","keys","map","key","date","timeParse","value","length","getMostRecentPrediction","p","substring","defined","console","log","confirmedStartDate","predStartDate","predLength","predEndDate","timeDay","offset","filter","d","x","scaleTime","domain","range","xAxis","call","axisBottom","confirmedMax","max","forecastMax","forecastData","f","currMax","yAxisMax","Math","y","scaleLinear","nice","axisLeft","legendString","concat","color","scaleOrdinal","schemeTableau10","legend","size","selectAll","data","enter","i","style","text","lineGenerator","line","curve","curveBasis","predLineGenerator","mainClip","mainArea","confirmedLine","datum","confirmedAreaEndX","confirmedAreaEndY","predictionClip","predictionArea","idxOfStartDate","bisector","aggregateData","splice","aggregateLine","index","lines","document","getElementsByClassName","predLine","yourLine","currDate","confirmedLastVal","filteredData","o","push","name","mouseArea","confirmedAreaWidth","node","getBoundingClientRect","clickAreaWidth","drawingInstruction","selectCircle","pointerCircles","c","drag","on","pos","mouse","clamp","invert","forEach","round","tooltipArea","mousePerLine","xCoord","a","b","floor","ceil","element","toFixed","focusHeight","contextMargin","context","contextX","contextXAxis","brush","brushX","extent","brushed","brushended","defaultSelection","timeMonth","event","selection","newX","gb","move","deleteButton","createElement","innerText","onclick","deletePrediction","filtered","querySelector","appendChild","render"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAO,KAAKC,EAAZ,MAAoB,IAApB;AACA,OAAO,2BAAP;;AAEA,MAAMC,mBAAN,SAAkCF,SAAlC,CAA4C;AACxCG,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAa;AAAEC,MAAAA,QAAQ,EAAE;AAAZ,KAAb;AACA,SAAKC,QAAL,GAAgBR,KAAK,CAACS,SAAN,EAAhB;AACH;;AAEDC,EAAAA,iBAAiB,GAAG;AAChB;AACA,SAAKC,WAAL;AACH;;AACDA,EAAAA,WAAW,GAAG;AACV,UAAM;AAAEC,MAAAA,QAAF;AAAYC,MAAAA,IAAZ;AAAkBC,MAAAA,cAAlB;AAAkCC,MAAAA,SAAlC;AAA6CC,MAAAA;AAA7C,QAA2D,KAAKX,KAAtE;AACA,QAAIY,cAAc,GAAG,EAArB,CAFU,CAEc;;AACxB,QAAIC,qBAAqB,GAAG,EAA5B;AACA,UAAMC,cAAc,GAAG,KAAKA,cAA5B;AACA,UAAMC,uBAAuB,GAAG,KAAKA,uBAArC;AACA,UAAMb,QAAQ,GAAG,KAAKD,KAAL,CAAWC,QAA5B;AACA,QAAIc,YAAY,GAAG,EAAnB,CAPU,CAQV;;AACA,UAAMC,WAAW,GAAG,GAApB;AACA,UAAMC,aAAa,GAAG,EAAtB,CAVU,CAUgB;;AAC1B,UAAMC,aAAa,GAAG,GAAtB;AACA,QAAIC,MAAM,GAAG;AAACC,MAAAA,GAAG,EAAE,EAAN;AAAUC,MAAAA,KAAK,EAAE,EAAjB;AAAqBC,MAAAA,MAAM,EAAE,EAA7B;AAAiCC,MAAAA,IAAI,EAAE;AAAvC,KAAb;AAAA,QACIC,KAAK,GAAG,MAAML,MAAM,CAACI,IAAb,GAAoBJ,MAAM,CAACE,KADvC;AAAA,QAEII,MAAM,GAAG,MAAMN,MAAM,CAACC,GAAb,GAAmBD,MAAM,CAACG,MAFvC;AAGA,QAAII,GAAG,GAAG9B,EAAE,CAAC+B,MAAH,CAAU,KAAKzB,QAAL,CAAc0B,OAAxB,EACGC,MADH,CACU,KADV,EAEOC,IAFP,CAEY,OAFZ,EAEqBN,KAAK,GAAGL,MAAM,CAACI,IAAf,GAAsBJ,MAAM,CAACE,KAA7B,GAAqCL,WAF1D,EAGOc,IAHP,CAGY,QAHZ,EAGsBL,MAAM,GAAGN,MAAM,CAACC,GAAhB,GAAsBD,MAAM,CAACG,MAA7B,GAAsCL,aAAtC,GAAsDC,aAH5E,EAIGW,MAJH,CAIU,GAJV,EAKOC,IALP,CAKY,WALZ,EAMM,eAAeX,MAAM,CAACI,IAAtB,GAA6B,GAA7B,GAAmCJ,MAAM,CAACC,GAA1C,GAAgD,GANtD,CAAV,CAfU,CAwBV;;AACA,QAAIW,aAAa,GAAGC,MAAM,CAACC,IAAP,CAAYxB,SAAZ,EAAuByB,GAAvB,CAA2BC,GAAG,KAAK;AACnDC,MAAAA,IAAI,EAAExC,EAAE,CAACyC,SAAH,CAAa,UAAb,EAAyBF,GAAzB,CAD6C;AAEnDG,MAAAA,KAAK,EAAE7B,SAAS,CAAC0B,GAAD;AAFmC,KAAL,CAA9B,CAApB,CAzBU,CA8BV;;AACA,QAAGH,MAAM,CAACC,IAAP,CAAYzB,cAAZ,EAA4B+B,MAA5B,GAAqC,CAAxC,EAA2C;AACvC5B,MAAAA,cAAc,GAAG6B,uBAAuB,CAAChC,cAAD,CAAvB,CAAwC0B,GAAxC,CAA4CO,CAAC,KAAK;AAC/DL,QAAAA,IAAI,EAAExC,EAAE,CAACyC,SAAH,CAAa,UAAb,EAA0BI,CAAC,CAACL,IAAH,CAASM,SAAT,CAAmB,CAAnB,EAAqB,EAArB,CAAzB,CADyD;AAE/DJ,QAAAA,KAAK,EAAEG,CAAC,CAACH,KAFsD;AAG/DK,QAAAA,OAAO,EAAEF,CAAC,CAACE;AAHoD,OAAL,CAA7C,CAAjB;AAMH;;AACDC,IAAAA,OAAO,CAACC,GAAR,CAAYlC,cAAZ,EAvCU,CAyCV;;AACA,UAAMmC,kBAAkB,GAAGlD,EAAE,CAACyC,SAAH,CAAa,UAAb,EAAyB,YAAzB,CAA3B,CA1CU,CA0CyD;;AACnE,UAAMU,aAAa,GAAGhB,aAAa,CAACA,aAAa,CAACQ,MAAd,GAAuB,CAAxB,CAAb,CAAwCH,IAA9D,CA3CU,CA2C0D;;AACpE,UAAMY,UAAU,GAAG,GAAnB,CA5CU,CA6CV;;AACA,UAAMC,WAAW,GAAGrD,EAAE,CAACsD,OAAH,CAAWC,MAAX,CAAkBJ,aAAlB,EAAiCC,UAAjC,CAApB,CA9CU,CAgDV;;AACAjB,IAAAA,aAAa,GAAGA,aAAa,CAACqB,MAAd,CAAqBC,CAAC,IAAI,CAACA,CAAC,CAACjB,IAAH,IAAW,CAACU,kBAAtC,CAAhB,CAjDU,CAmDV;;AACA,QAAIQ,CAAC,GAAG1D,EAAE,CAAC2D,SAAH,GACHC,MADG,CACI,CAACV,kBAAD,EAAqBG,WAArB,CADJ,EAEHQ,KAFG,CAEG,CAAE,CAAF,EAAKjC,KAAL,CAFH,CAAR,CApDU,CAuDN;;AACJ,QAAIkC,KAAK,GAAGhC,GAAG,CACEG,MADL,CACY,GADZ,EAEKC,IAFL,CAEU,WAFV,EAEuB,iBAAiBL,MAAjB,GAA0B,GAFjD,EAGKkC,IAHL,CAGU/D,EAAE,CAACgE,UAAH,CAAcN,CAAd,CAHV,CAAZ,CAxDU,CA6DV;;AACA,QAAIO,YAAY,GAAGjE,EAAE,CAACkE,GAAH,CAAO/B,aAAP,EAAsB,UAASsB,CAAT,EAAY;AAAE,aAAO,CAACA,CAAC,CAACf,KAAV;AAAkB,KAAtD,CAAnB;AACA,QAAIyB,WAAW,GAAG,CAAlB;AACAC,IAAAA,YAAY,CAAC9B,GAAb,CAAiB+B,CAAC,IAAI;AAClB,UAAIC,OAAO,GAAGtE,EAAE,CAACkE,GAAH,CAAOG,CAAP,EAAUZ,CAAC,IAAI;AAAC,eAAOA,CAAC,CAACf,KAAT;AAAgB,OAAhC,CAAd;AACAyB,MAAAA,WAAW,GAAGG,OAAO,GAAGH,WAAV,GAAwBG,OAAxB,GAAkCH,WAAhD;AACH,KAHD;AAIA,QAAII,QAAQ,GAAGC,IAAI,CAACN,GAAL,CAASD,YAAT,EAAuBE,WAAvB,CAAf,CApEU,CAqEV;;AACA,QAAIM,CAAC,GAAGzE,EAAE,CAAC0E,WAAH,GACHd,MADG,CACI,CAAC,CAAD,EAAIW,QAAJ,CADJ,EAEHV,KAFG,CAEG,CAAEhC,MAAF,EAAU,CAAV,CAFH,EAGH8C,IAHG,EAAR;AAIA7C,IAAAA,GAAG,CACEG,MADL,CACY,GADZ,EAEK8B,IAFL,CAEU/D,EAAE,CAAC4E,QAAH,CAAYH,CAAZ,CAFV,EA1EU,CA8EV;;AACA,QAAII,YAAY,GAAGlE,IAAI,CAACmE,MAAL,CAAY,CAAC,wBAAD,EAA2B,oBAA3B,EAAiD,iBAAjD,CAAZ,CAAnB,CA/EU,CAgFV;;AACA,QAAIC,KAAK,GAAG/E,EAAE,CACGgF,YADL,GAEKpB,MAFL,CAEYiB,YAFZ,EAGKhB,KAHL,CAGW7D,EAAE,CAACiF,eAHd,CAAZ,CAjFU,CAsFT;;AACD,QAAIC,MAAM,GAAGpD,GAAG,CAACG,MAAJ,CAAW,GAAX,EACIC,IADJ,CACS,IADT,EACe,QADf,CAAb;AAEA,QAAIiD,IAAI,GAAG,EAAX;AACAD,IAAAA,MAAM,CAACE,SAAP,CAAiB,MAAjB,EACKC,IADL,CACUR,YADV,EAEKS,KAFL,GAGKrD,MAHL,CAGY,QAHZ,EAISC,IAJT,CAIc,IAJd,EAIoBN,KAAK,GAAG,EAJ5B,EAKSM,IALT,CAKc,IALd,EAKoB,UAASuB,CAAT,EAAW8B,CAAX,EAAa;AAAE,aAAO,KAAKA,CAAC,GAAC,EAAd;AAAiB,KALpD,EAKsD;AALtD,KAMSrD,IANT,CAMc,GANd,EAMmB,CANnB,EAOQ;AACA;AARR,KASSsD,KATT,CASe,MATf,EASuB,UAAS/B,CAAT,EAAW;AAAE,aAAOsB,KAAK,CAACtB,CAAD,CAAZ;AAAgB,KATpD;AAUAyB,IAAAA,MAAM,CAACE,SAAP,CAAiB,QAAjB,EACKC,IADL,CACUR,YADV,EAEKS,KAFL,GAGKrD,MAHL,CAGY,MAHZ,EAISC,IAJT,CAIc,GAJd,EAImBN,KAAK,GAAG,EAJ3B,EAKSM,IALT,CAKc,GALd,EAKmB,UAASuB,CAAT,EAAW8B,CAAX,EAAa;AAAE,aAAO,KAAKA,CAAC,GAAC,EAAd;AAAiB,KALnD,EAKqD;AALrD,KAMSC,KANT,CAMe,MANf,EAMuB,UAAS/B,CAAT,EAAW;AAAE,aAAOsB,KAAK,CAACtB,CAAD,CAAZ;AAAgB,KANpD,EAOSgC,IAPT,CAOc,UAAShC,CAAT,EAAW;AAAE,aAAOA,CAAP;AAAS,KAPpC,EAQavB,IARb,CAQkB,aARlB,EAQiC,MARjC,EASasD,KATb,CASmB,oBATnB,EASyC,QATzC,EApGU,CA+GV;;AACA,QAAIE,aAAa,GAAG1F,EAAE,CAAC2F,IAAH,GACfC,KADe,CACT5F,EAAE,CAAC6F,UADM,CAApB,CAhHU,CAkHN;;AACJ,QAAIC,iBAAiB,GAAG9F,EAAE,CAAC2F,IAAH,GACnBC,KADmB,CACb5F,EAAE,CAAC6F,UADU,CAAxB,CAnHU,CAoHiB;AACvB;AACA;AACA;AAEJ;;AACA,QAAIF,IAAI,GAAGD,aAAa,CACnBhC,CADM,CACJ,UAASD,CAAT,EAAY;AAAE,aAAOC,CAAC,CAACD,CAAC,CAACjB,IAAH,CAAR;AAAkB,KAD5B,EAENiC,CAFM,CAEJ,UAAShB,CAAT,EAAY;AAAE,aAAOgB,CAAC,CAAChB,CAAC,CAACf,KAAH,CAAR;AAAmB,KAF7B,CAAX,CA1HU,CA8HV;;AACA,QAAIqD,QAAQ,GAAGjE,GAAG,CACGG,MADN,CACa,MADb,EAEMA,MAFN,CAEa,cAFb,EAGUC,IAHV,CAGe,IAHf,EAGqB,WAHrB,EAIUD,MAJV,CAIiB,UAJjB,EAKcC,IALd,CAKmB,OALnB,EAK4BN,KAL5B,EAMcM,IANd,CAMmB,QANnB,EAM6BL,MAN7B,EAOcK,IAPd,CAOmB,GAPnB,EAOwB,CAPxB,EAQcA,IARd,CAQmB,GARnB,EAQwB,CARxB,CAAf,CA/HU,CAyIV;;AACA,UAAM8D,QAAQ,GAAGlE,GAAG,CACKG,MADR,CACe,GADf,EAEQC,IAFR,CAEa,WAFb,EAE0B,iBAF1B,CAAjB,CA1IU,CA8IV;;AACA,QAAI+D,aAAa,GAAGD,QAAQ,CAAC/D,MAAT,CAAgB,MAAhB,EACSC,IADT,CACc,IADd,EACoB,WADpB,EAESA,IAFT,CAEc,OAFd,EAEuB,MAFvB,EAGSgE,KAHT,CAGe/D,aAHf,EAISD,IAJT,CAIc,GAJd,EAImByD,IAJnB,EAKSzD,IALT,CAKc,QALd,EAKwB6C,KAAK,CAACF,YAAY,CAACA,YAAY,CAAClC,MAAb,GAAsB,CAAvB,CAAb,CAL7B,CAApB;AAMA,QAAIwD,iBAAiB,GAAGzC,CAAC,CAACvB,aAAa,CAACA,aAAa,CAACQ,MAAd,GAAuB,CAAxB,CAAb,CAAwCH,IAAzC,CAAzB;AACA,QAAI4D,iBAAiB,GAAG3B,CAAC,CAACtC,aAAa,CAACA,aAAa,CAACQ,MAAd,GAAuB,CAAxB,CAAb,CAAwCD,KAAzC,CAAzB,CAtJU,CAwJV;;AACA,QAAI2D,cAAc,GAAGvE,GAAG,CAACG,MAAJ,CAAW,MAAX,EAAmBA,MAAnB,CAA0B,cAA1B,EACIC,IADJ,CACS,IADT,EACe,iBADf,EAEID,MAFJ,CAEW,UAFX,EAGQC,IAHR,CAGa,OAHb,EAGsBN,KAAK,GAAGuE,iBAH9B,EAIQjE,IAJR,CAIa,QAJb,EAIuBL,MAJvB,EAKQK,IALR,CAKa,GALb,EAKkBiE,iBALlB,EAMQjE,IANR,CAMa,GANb,EAMkB,CANlB,CAArB;AAOA,UAAMoE,cAAc,GAAGxE,GAAG,CAACG,MAAJ,CAAW,GAAX,EACFC,IADE,CACG,WADH,EACgB,uBADhB,CAAvB,CAhKU,CAmKV;;AACA,QAAIqE,cAAc,GAAGvG,EAAE,CAACwG,QAAH,CAAYnC,CAAC,IAAIA,CAAC,CAAC7B,IAAnB,EAAyBb,IAAzB,CAA8B8E,aAA9B,EAA6CtD,aAA7C,CAArB,CApKU,CAqKV;;AACA,QAAIsD,aAAa,CAAC9D,MAAd,GAAuB,CAAvB,IAA4B,CAAC8D,aAAa,CAACF,cAAD,CAAb,CAA8B/D,IAA/B,IAAuC,CAACW,aAAxE,EAAuF;AACnFsD,MAAAA,aAAa,CAACF,cAAD,CAAb,CAA8B7D,KAA9B,GAAsCP,aAAa,CAACA,aAAa,CAACQ,MAAd,GAAuB,CAAxB,CAAb,CAAwCD,KAA9E;AACH,KAFD,MAGK;AACD+D,MAAAA,aAAa,CAACC,MAAd,CAAqBH,cAArB,EAAqC,CAArC,EAAwC;AACpC/D,QAAAA,IAAI,EAAEW,aAD8B;AAEpCT,QAAAA,KAAK,EAAEP,aAAa,CAACA,aAAa,CAACQ,MAAd,GAAuB,CAAxB,CAAb,CAAwCD;AAFX,OAAxC;AAIAM,MAAAA,OAAO,CAACC,GAAR,CAAYwD,aAAZ;AACAzD,MAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ;AACH,KAhLS,CAkLV;;;AACA,QAAI0D,aAAa,GAAGL,cAAc,CAACrE,MAAf,CAAsB,MAAtB,EACSC,IADT,CACc,IADd,EACoB,WADpB,EAESA,IAFT,CAEc,OAFd,EAEuB,MAFvB,EAGSgE,KAHT,CAGeO,aAHf,EAISvE,IAJT,CAIc,GAJd,EAImByD,IAJnB,EAKSzD,IALT,CAKc,QALd,EAKwB6C,KAAK,CAACF,YAAY,CAACA,YAAY,CAAClC,MAAb,GAAsB,CAAvB,CAAb,CAL7B,CAApB,CAnLU,CA0LV;;AACAyB,IAAAA,YAAY,CAAC9B,GAAb,CAAiB,CAAC+B,CAAD,EAAIuC,KAAJ,KAAc;AAC3B;AACA;AACA,UAAIL,cAAc,GAAGvG,EAAE,CAACwG,QAAH,CAAYnC,CAAC,IAAIA,CAAC,CAAC7B,IAAnB,EAAyBb,IAAzB,CAA8B0C,CAA9B,EAAiClB,aAAjC,CAArB,CAH2B,CAI3B;;AACA,UAAIkB,CAAC,CAAC1B,MAAF,GAAW,CAAX,IAAgB,CAAC0B,CAAC,CAACkC,cAAD,CAAD,CAAkB/D,IAAnB,IAA2B,CAACW,aAAhD,EAA+D;AAC3DkB,QAAAA,CAAC,CAACkC,cAAD,CAAD,CAAkB7D,KAAlB,GAA0BP,aAAa,CAACA,aAAa,CAACQ,MAAd,GAAuB,CAAxB,CAAb,CAAwCD,KAAlE;AACH,OAFD,MAGK;AACD2B,QAAAA,CAAC,CAACqC,MAAF,CAASH,cAAT,EAAyB,CAAzB,EAA4B;AACxB/D,UAAAA,IAAI,EAAEW,aADkB;AAExBT,UAAAA,KAAK,EAAEP,aAAa,CAACA,aAAa,CAACQ,MAAd,GAAuB,CAAxB,CAAb,CAAwCD;AAFvB,SAA5B;AAIAM,QAAAA,OAAO,CAACC,GAAR,CAAYoB,CAAZ;AACArB,QAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ;AACH;;AACDD,MAAAA,OAAO,CAACC,GAAR,CAAYoB,CAAZ;AACArB,MAAAA,OAAO,CAACC,GAAR,CAAYsD,cAAZ;AACAD,MAAAA,cAAc,CAACrE,MAAf,CAAsB,MAAtB,EACaC,IADb,CACkB,OADlB,EAC2B,eAD3B,EAEaA,IAFb,CAEkB,IAFlB,EAEwBvB,IAAI,CAACiG,KAAD,CAF5B,EAGapB,KAHb,CAGmB,QAHnB,EAG6BT,KAAK,CAACpE,IAAI,CAACiG,KAAD,CAAL,CAHlC,EAIaV,KAJb,CAImB7B,CAJnB,EAKiBnC,IALjB,CAKsB,GALtB,EAK2ByD,IAL3B;AAMH,KAxBD;AA0BA,QAAIkB,KAAK,GAAGC,QAAQ,CAACC,sBAAT,CAAgC,MAAhC,CAAZ,CArNU,CAuNV;;AACA,QAAIC,QAAQ,GAAGlB,iBAAiB,CAC3B/C,OADU,CACFU,CAAC,IAAIA,CAAC,CAACV,OADL,EAEVW,CAFU,CAER,UAASD,CAAT,EAAY;AAAE,aAAOC,CAAC,CAACD,CAAC,CAACjB,IAAH,CAAR;AAAkB,KAFxB,EAGViC,CAHU,CAGR,UAAShB,CAAT,EAAY;AAAE,aAAOgB,CAAC,CAAChB,CAAC,CAACf,KAAH,CAAR;AAAmB,KAHzB,CAAf,CAxNU,CA6NV;;AACA,QAAIuE,QAAQ,GAAGX,cAAc,CACIrE,MADlB,CACyB,MADzB,EAEkBC,IAFlB,CAEuB,IAFvB,EAE6B,WAF7B,CAAf,CA9NU,CAmOV;;AACA,QAAIgF,QAAQ,GAAG/D,aAAf;AACA,QAAIJ,OAAO,GAAG,IAAd;AACA,QAAIL,KAAK,GAAGP,aAAa,CAACA,aAAa,CAACQ,MAAd,GAAuB,CAAxB,CAAb,CAAwCD,KAApD;AACA,UAAMyE,gBAAgB,GAAGzE,KAAzB,CAvOU,CAuOsB;AAEhC;;AACA,QAAIN,MAAM,CAACC,IAAP,CAAYzB,cAAZ,EAA4B+B,MAA5B,GAAqC,CAAzC,EAA4C;AACxC5B,MAAAA,cAAc,GAAGA,cAAc,CAACyC,MAAf,CAAsBC,CAAC,IAAK,CAACA,CAAC,CAACjB,IAAH,IAAW,CAACW,aAAb,IAAgC,CAACM,CAAC,CAACjB,IAAH,IAAW,CAACa,WAAvE,CAAjB;AACAtC,MAAAA,cAAc,CAAC,CAAD,CAAd,CAAkB2B,KAAlB,GAA0ByE,gBAA1B;AACApG,MAAAA,cAAc,CAAC,CAAD,CAAd,CAAkBgC,OAAlB,GAA4B,IAA5B;AACAmE,MAAAA,QAAQ,GAAGlH,EAAE,CAACsD,OAAH,CAAWC,MAAX,CAAkBxC,cAAc,CAACA,cAAc,CAAC4B,MAAf,GAAwB,CAAzB,CAAd,CAA0CH,IAA5D,EAAkE,CAAlE,CAAX,CAJwC,CAKxC;;AACAQ,MAAAA,OAAO,CAACC,GAAR,CAAYlC,cAAZ;AACAiC,MAAAA,OAAO,CAACC,GAAR,CAAY/B,uBAAuB,CAACgG,QAAD,EAAW7D,WAAX,CAAnC;AACAtC,MAAAA,cAAc,CAAC+D,MAAf,CAAsB5D,uBAAuB,CAACgG,QAAD,EAAW7D,WAAX,CAA7C;AACAL,MAAAA,OAAO,CAACC,GAAR,CAAYlC,cAAZ;AACH,KAVD,MAWK;AACDA,MAAAA,cAAc,GAAGG,uBAAuB,CAACiC,aAAD,EAAgBE,WAAhB,CAAxC;AACAtC,MAAAA,cAAc,CAAC,CAAD,CAAd,CAAkB2B,KAAlB,GAA0ByE,gBAA1B;AACApG,MAAAA,cAAc,CAAC,CAAD,CAAd,CAAkBgC,OAAlB,GAA4B,IAA5B;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAYlC,cAAZ;AACH;;AAED,QAAIqG,YAAY,GAAG,IAAnB,CA5PU,CA6PV;AAER;;AACQzG,IAAAA,IAAI,CAAC2B,GAAL,CAAS,CAAC+E,CAAD,EAAIT,KAAJ,KAAc;AACnBzF,MAAAA,YAAY,CAACmG,IAAb,CAAkB;AACdC,QAAAA,IAAI,EAAEF,CADQ;AAEdhC,QAAAA,IAAI,EAAEjB,YAAY,CAACwC,KAAD;AAFJ,OAAlB;AAIH,KALD;AAMAzF,IAAAA,YAAY,CAACmG,IAAb,CAAkB;AACdC,MAAAA,IAAI,EAAE,wBADQ;AAEdlC,MAAAA,IAAI,EAAElD;AAFQ,KAAlB;AAIAhB,IAAAA,YAAY,CAACmG,IAAb,CAAkB;AACdC,MAAAA,IAAI,EAAE,oBADQ;AAEdlC,MAAAA,IAAI,EAAEoB;AAFQ,KAAlB,EA1QU,CA8QV;;AACAtF,IAAAA,YAAY,CAACmG,IAAb,CAAkB;AACdC,MAAAA,IAAI,EAAE,iBADQ;AAEdlC,MAAAA,IAAI,EAAEtE;AAFQ,KAAlB,EA/QU,CAmRV;AACA;;AACAqG,IAAAA,YAAY,GAAGrG,cAAc,CAACyC,MAAf,CAAsBwD,QAAQ,CAACjE,OAAT,EAAtB,CAAf;AACAkE,IAAAA,QAAQ,CAACf,KAAT,CAAekB,YAAf,EACSlF,IADT,CACc,GADd,EACmB8E,QADnB,EAESxB,KAFT,CAEe,QAFf,EAEyBT,KAAK,CAACF,YAAY,CAACA,YAAY,CAAClC,MAAb,GAAsB,CAAvB,CAAb,CAF9B,EAtRU,CAyRV;;AACA,UAAM6E,SAAS,GAAG1F,GAAG,CAACG,MAAJ,CAAW,MAAX,EACbC,IADa,CACR,OADQ,EACCN,KADD,EAEbM,IAFa,CAER,QAFQ,EAEEL,MAFF,EAGbK,IAHa,CAGR,MAHQ,EAGA,MAHA,EAIbA,IAJa,CAIR,IAJQ,EAIF,YAJE,EAKbsD,KALa,CAKP,gBALO,EAKU,SALV,CAAlB,CA1RU,CAiSV;;AACA,QAAIiC,kBAAkB,GAAGxB,aAAa,CAACyB,IAAd,GAAqBC,qBAArB,GAA6C/F,KAAtE,CAlSU,CAkSmE;;AAC7EoB,IAAAA,OAAO,CAACC,GAAR,CAAYwE,kBAAZ;AACA,QAAIG,cAAc,GAAGhG,KAAK,GAAG6F,kBAA7B,CApSU,CAoSuC;;AACjD3F,IAAAA,GAAG,CAACG,MAAJ,CAAW,MAAX,EACIC,IADJ,CACS,IADT,EACe,YADf,EAEIA,IAFJ,CAES,OAFT,EAEkB0F,cAFlB,EAGI1F,IAHJ,CAGS,QAHT,EAGkBL,MAHlB,EAIIK,IAJJ,CAIS,WAJT,EAIsB,gBAAgBuF,kBAAhB,GAAmC,KAJzD,EAKIvF,IALJ,CAKS,MALT,EAKiB,MALjB,EAMIsD,KANJ,CAMU,gBANV,EAM2B,SAN3B,EArSU,CA4SV;AAEA;;AACA,UAAMqC,kBAAkB,GAAG/F,GAAG,CACGG,MADN,CACa,GADb,EAEMC,IAFN,CAEW,IAFX,EAEiB,qBAFjB,EAGMsD,KAHN,CAGY,SAHZ,EAGuB,GAHvB,CAA3B;AAIAqC,IAAAA,kBAAkB,CACG5F,MADrB,CAC4B,MAD5B,EAEqBC,IAFrB,CAE0B,IAF1B,EAEgC,YAFhC,EAGqBA,IAHrB,CAG0B,GAH1B,EAG+BiE,iBAAiB,GAAG,CAACvE,KAAK,GAAGuE,iBAAT,IAA8B,CAHjF,EAIqBjE,IAJrB,CAI0B,GAJ1B,EAI+BL,MAAM,GAAG,GAJxC,EAKqBK,IALrB,CAK0B,aAL1B,EAKyC,QALzC,EAMqBuD,IANrB,CAM0B,iBAN1B,EAOqBD,KAPrB,CAO2B,WAP3B,EAOwC,MAPxC,EAnTU,CA2TV;;AACA,QAAIsC,YAAY,GAAGD,kBAAkB,CACI5F,MADtB,CAC6B,GAD7B,EAEsBC,IAFtB,CAE2B,IAF3B,EAEiC,SAFjC,CAAnB;AAGA,QAAI6F,cAAc,GAAG,CAAC,YAAD,EAAe,cAAf,EAA+B,gBAA/B,CAArB;AACAA,IAAAA,cAAc,CAACzF,GAAf,CAAoB0F,CAAD,IAAO;AAC1BF,MAAAA,YAAY,CAAC7F,MAAb,CAAoB,QAApB,EACKC,IADL,CACU,OADV,EACmB8F,CADnB,EAEK9F,IAFL,CAEU,IAFV,EAEgBiE,iBAFhB,EAGKjE,IAHL,CAGU,IAHV,EAGgBkE,iBAHhB;AAIC,KALD;;AAOA,QAAGhE,MAAM,CAACC,IAAP,CAAYzB,cAAZ,EAA4B+B,MAA5B,IAAsC,CAAzC,EAA4C;AACxCb,MAAAA,GAAG,CACEC,MADL,CACY,sBADZ,EAEKyD,KAFL,CAEW,SAFX,EAEsB,GAFtB;AAGH;;AAED,QAAIyC,IAAI,GAAGjI,EAAE,CAACiI,IAAH,GACGC,EADH,CACM,MADN,EACc,YAAW;AACpB;AACApG,MAAAA,GAAG,CACEC,MADL,CACY,sBADZ,EAEKyD,KAFL,CAEW,SAFX,EAEsB,GAFtB;AAGAxF,MAAAA,EAAE,CAAC+B,MAAH,CAAU,eAAV,EACKyD,KADL,CACW,SADX,EACsB,GADtB;AAEAxF,MAAAA,EAAE,CAACoF,SAAH,CAAa,wBAAb,EACKI,KADL,CACW,SADX,EACsB,GADtB;AAEAxF,MAAAA,EAAE,CAACoF,SAAH,CAAa,sBAAb,EACKI,KADL,CACW,SADX,EACsB,GADtB;AAEA,UAAI2C,GAAG,GAAGnI,EAAE,CAACoI,KAAH,CAAS,IAAT,CAAV;AACA,UAAI5F,IAAI,GAAG6F,KAAK,CAAClF,aAAD,EAAgBE,WAAhB,EAA6BK,CAAC,CAAC4E,MAAF,CAASH,GAAG,CAAC,CAAD,CAAZ,CAA7B,CAAhB;AACA,UAAIzF,KAAK,GAAG2F,KAAK,CAAC,CAAD,EAAI9D,QAAJ,EAAcE,CAAC,CAAC6D,MAAF,CAASH,GAAG,CAAC,CAAD,CAAZ,CAAd,CAAjB;AAEApH,MAAAA,cAAc,CAACwH,OAAf,CAAuB,UAAS9E,CAAT,EAAW;AAC9B,YAAI,CAACzD,EAAE,CAACsD,OAAH,CAAWkF,KAAX,CAAiB/E,CAAC,CAACjB,IAAnB,CAAD,IAA6B,CAACxC,EAAE,CAACsD,OAAH,CAAWkF,KAAX,CAAiBhG,IAAjB,CAAlC,EAAyD;AACrDiB,UAAAA,CAAC,CAACf,KAAF,GAAUA,KAAV;AACAe,UAAAA,CAAC,CAACV,OAAF,GAAY,IAAZ;AACH;;AACLhC,QAAAA,cAAc,CAAC,CAAD,CAAd,CAAkB2B,KAAlB,GAA0ByE,gBAA1B,CALkC,CAKS;AAC3C;;AACAhG,QAAAA,YAAY,CAACA,YAAY,CAACwB,MAAb,GAAsB,CAAvB,CAAZ,CAAsC0C,IAAtC,GAA6CtE,cAA7C,CAPkC,CAQlC;;AACA;;;AAEA,YAAIqG,YAAY,GAAGrG,cAAc,CAACyC,MAAf,CAAsBwD,QAAQ,CAACjE,OAAT,EAAtB,CAAnB;AAEAkE,QAAAA,QAAQ,CAACf,KAAT,CAAekB,YAAf,EACSlF,IADT,CACc,GADd,EACmB8E,QADnB,EAESxB,KAFT,CAEe,QAFf,EAEyBT,KAAK,CAACF,YAAY,CAACA,YAAY,CAAClC,MAAb,GAAsB,CAAvB,CAAb,CAF9B;AAIC,OAjBD;AAkBH,KAlCF,EAmCEuF,EAnCF,CAmCK,KAnCL,EAmCY,YAAY;AACnBjH,MAAAA,cAAc,CAACF,cAAD,EAAiBV,QAAjB,CAAd;AACAL,MAAAA,EAAE,CAAC+B,MAAH,CAAU,eAAV,EACKyD,KADL,CACW,SADX,EACsB,GADtB;AAEAxF,MAAAA,EAAE,CAACoF,SAAH,CAAa,wBAAb,EACKI,KADL,CACW,SADX,EACsB,GADtB;AAEAxF,MAAAA,EAAE,CAACoF,SAAH,CAAa,sBAAb,EACKI,KADL,CACW,SADX,EACsB,GADtB;AAEH,KA3CF,CAAX;AA6CA1D,IAAAA,GAAG,CAACiC,IAAJ,CAASkE,IAAT,EA1XU,CA4XV;;AACA;;;;;;;;;;;AAYA,UAAMQ,WAAW,GAAG3G,GAAG,CACEG,MADL,CACY,GADZ,EAEKC,IAFL,CAEU,OAFV,EAEmB,SAFnB,CAApB;AAIAuG,IAAAA,WAAW,CAACxG,MAAZ,CAAmB,MAAnB,EAA2B;AAA3B,KACaC,IADb,CACkB,IADlB,EACwB,cADxB,EAEasD,KAFb,CAEmB,QAFnB,EAE6B,OAF7B,EAGaA,KAHb,CAGmB,cAHnB,EAGmC,OAHnC,EAIaA,KAJb,CAImB,SAJnB,EAI8B,GAJ9B;AAMA,QAAIkD,YAAY,GAAGD,WAAW,CACGrD,SADd,CACwB,iBADxB,EAEcC,IAFd,CAEmBlE,YAFnB,EAGcmE,KAHd,GAIcrD,MAJd,CAIqB,GAJrB,EAKcC,IALd,CAKmB,OALnB,EAK4B,gBAL5B,CAAnB;AAOAwG,IAAAA,YAAY,CAACzG,MAAb,CAAoB,QAApB,EACiBC,IADjB,CACsB,GADtB,EAC2B,CAD3B,EAEiBsD,KAFjB,CAEuB,QAFvB,EAEiC,UAAS/B,CAAT,EAAY;AACzB,aAAOsB,KAAK,CAACtB,CAAC,CAAC8D,IAAH,CAAZ;AACH,KAJjB,EAKiB/B,KALjB,CAKuB,MALvB,EAK+B,MAL/B,EAMiBA,KANjB,CAMuB,cANvB,EAMuC,KANvC,EAOiBA,KAPjB,CAOuB,SAPvB,EAOkC,GAPlC;AAQAkD,IAAAA,YAAY,CAACzG,MAAb,CAAoB,MAApB,EACaC,IADb,CACkB,WADlB,EAC+B,iBAD/B;AAEAuG,IAAAA,WAAW,CACExG,MADb,CACoB,UADpB,EAEaC,IAFb,CAEkB,OAFlB,EAE2BN,KAF3B,EAGaM,IAHb,CAGkB,QAHlB,EAG4BL,MAH5B,EAIaK,IAJb,CAIkB,MAJlB,EAI0B,MAJ1B,EAKaA,IALb,CAKkB,gBALlB,EAKoC,KALpC,EAMasD,KANb,CAMmB,QANnB,EAM6B,SAN7B,EAOa0C,EAPb,CAOgB,UAPhB,EAO4B,YAAW;AAAE;AACzBlI,MAAAA,EAAE,CAAC+B,MAAH,CAAU,eAAV,EACGyD,KADH,CACS,SADT,EACoB,GADpB;AAEAxF,MAAAA,EAAE,CAACoF,SAAH,CAAa,wBAAb,EACGI,KADH,CACS,SADT,EACoB,GADpB;AAEAxF,MAAAA,EAAE,CAACoF,SAAH,CAAa,sBAAb,EACGI,KADH,CACS,SADT,EACoB,GADpB;AAEH,KAdb,EAea0C,EAfb,CAegB,WAfhB,EAe6B,YAAW;AAAE;AAC1BlI,MAAAA,EAAE,CAAC+B,MAAH,CAAU,eAAV,EACGyD,KADH,CACS,SADT,EACoB,GADpB;AAEAxF,MAAAA,EAAE,CAACoF,SAAH,CAAa,wBAAb,EACGI,KADH,CACS,SADT,EACoB,GADpB;AAEAxF,MAAAA,EAAE,CAACoF,SAAH,CAAa,sBAAb,EACGI,KADH,CACS,SADT,EACoB,GADpB;AAGH,KAvBb,EAwBa0C,EAxBb,CAwBgB,WAxBhB,EAwB6B,YAAW;AAAE;AAC1B,UAAIE,KAAK,GAAGpI,EAAE,CAACoI,KAAH,CAAS,IAAT,CAAZ;AACA,UAAIO,MAAM,GAAGP,KAAK,CAAC,CAAD,CAAlB;AACApI,MAAAA,EAAE,CACG+B,MADL,CACY,eADZ,EAEKG,IAFL,CAEU,GAFV,EAEe,YAAW;AAClB,YAAIuB,CAAC,GAAG,MAAMkF,MAAN,GAAe,GAAf,GAAqB9G,MAA7B;AACA4B,QAAAA,CAAC,IAAI,MAAMkF,MAAN,GAAe,GAAf,GAAqB,CAA1B;AACA,eAAOlF,CAAP;AACH,OANL;AAOAzD,MAAAA,EAAE,CACGoF,SADL,CACe,iBADf,EAEKlD,IAFL,CAEU,WAFV,EAEuB,UAASuB,CAAT,EAAY8B,CAAZ,EAAe;AAC9B,YAAI9B,CAAC,CAAC4B,IAAF,CAAO1C,MAAP,IAAiB,CAArB,EAAwB;AAAC;AAAQ;;AACjC,YAAIH,IAAI,GAAGkB,CAAC,CAAC4E,MAAF,CAASK,MAAT,CAAX;AACA,cAAM/B,KAAK,GAAG5G,EAAE,CAACwG,QAAH,CAAYnC,CAAC,IAAIA,CAAC,CAAC7B,IAAnB,EAAyBb,IAAzB,CAA8BR,YAAY,CAACoE,CAAD,CAAZ,CAAgBF,IAA9C,EAAoD7C,IAApD,CAAd;AACA,YAAIoG,CAAC,GAAG,IAAR;;AACA,YAAIhC,KAAK,GAAG,CAAZ,EAAe;AACXgC,UAAAA,CAAC,GAAGnF,CAAC,CAAC4B,IAAF,CAAOuB,KAAK,GAAG,CAAf,CAAJ;AACH;;AACD,cAAMiC,CAAC,GAAGpF,CAAC,CAAC4B,IAAF,CAAOuB,KAAP,CAAV,CAR8B,CAS9B;;AACA,YAAIvB,IAAI,GAAG,IAAX;;AACA,YAAI,CAACuD,CAAL,EAAQ;AACJvD,UAAAA,IAAI,GAAGwD,CAAP;AACH,SAFD,MAGK,IAAI,CAACA,CAAL,EAAQ;AACTxD,UAAAA,IAAI,GAAGuD,CAAP;AACH,SAFI,MAGA;AACDvD,UAAAA,IAAI,GAAGwD,CAAC,IAAKrG,IAAI,GAAGoG,CAAC,CAACpG,IAAT,GAAgBqG,CAAC,CAACrG,IAAF,GAASA,IAA/B,GAAuCqG,CAAvC,GAA2CD,CAAlD;AACH;;AACD,YAAI,CAAC5I,EAAE,CAACsD,OAAH,CAAWwF,KAAX,CAAiBtG,IAAjB,CAAD,IAA2B,CAAC6C,IAAI,CAAC7C,IAAjC,IAAyC,CAACxC,EAAE,CAACsD,OAAH,CAAWyF,IAAX,CAAgBvG,IAAhB,CAAD,IAA0B,CAAC6C,IAAI,CAAC7C,IAA7E,EAAmF;AAC/E,cAAI6C,IAAI,CAACtC,OAAL,IAAgB,CAApB,EAAuB;AACnB,gBAAIiG,OAAO,GAAGhJ,EAAE,CAAC+B,MAAH,CAAU,IAAV,EACGA,MADH,CACU,MADV,EAEOyD,KAFP,CAEa,SAFb,EAEwB,GAFxB,EAGOC,IAHP,CAGYjB,IAAI,CAACgE,KAAL,CAAWnD,IAAI,CAAC3C,KAAhB,EAAuBuG,OAAvB,CAA+B,CAA/B,CAHZ,CAAd;AAIAD,YAAAA,OAAO,CAACjH,MAAR,CAAe,QAAf,EACSyD,KADT,CACe,SADf,EAC0B,GAD1B;AAEA,mBAAO,eAAe4C,KAAK,CAAC,CAAD,CAApB,GAA0B,GAA1B,GAAgC3D,CAAC,CAACY,IAAI,CAAC3C,KAAN,CAAjC,GAA8C,GAArD;AACH;AACJ;;AACD,YAAIsG,OAAO,GAAGhJ,EAAE,CAAC+B,MAAH,CAAU,IAAV,EACGA,MADH,CACU,MADV,EAEGyD,KAFH,CAES,SAFT,EAEoB,GAFpB,CAAd;AAGAwD,QAAAA,OAAO,CACEjH,MADT,CACgB,QADhB,EAESyD,KAFT,CAEe,SAFf,EAE0B,GAF1B;AAIP,OAxCD;AAyCH,KA3Eb,EApaU,CAifV;;AACA,UAAM0D,WAAW,GAAG,GAApB;AACA,UAAMC,aAAa,GAAG,EAAtB;AACA,QAAIC,OAAO,GAAGtH,GAAG,CACIG,MADP,CACc,GADd,EAEWC,IAFX,CAEgB,SAFhB,EAE2B,CAAC,CAAD,EAAI,CAAJ,EAAON,KAAP,EAAcsH,WAAd,CAF3B,EAGWhH,IAHX,CAGgB,WAHhB,EAG8B,eAAcL,MAAM,GAAGsH,aAAc,IAHnE,EAIU;AACA;AALV,KAMW3D,KANX,CAMiB,SANjB,EAM4B,OAN5B,CAAd;AAUA;;;;AAIA,QAAI6D,QAAQ,GAAGrJ,EAAE,CACI2D,SADN,GAEMC,MAFN,CAEa,CAACV,kBAAD,EAAqBG,WAArB,CAFb,EAGMQ,KAHN,CAGY,CAAC,CAAD,EAAIjC,KAAJ,CAHZ,CAAf;AAKA,QAAI0H,YAAY,GAAGF,OAAO,CACGnH,MADV,CACiB,GADjB,EAEUC,IAFV,CAEe,WAFf,EAE6B,eAAcgH,WAAW,GAAG3H,MAAM,CAACG,MAAO,GAFvE,EAGUqC,IAHV,CAGe/D,EAAE,CAACgE,UAAH,CAAcqF,QAAd,CAHf,CAAnB;AAIA,UAAME,KAAK,GAAGvJ,EAAE,CAACwJ,MAAH,GACGC,MADH,CACU,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD,EAAS,CAAC7H,KAAD,EAAQsH,WAAW,GAAG3H,MAAM,CAACG,MAA7B,CAAT,CADV,EAEGwG,EAFH,CAEM,OAFN,EAEewB,OAFf,EAGGxB,EAHH,CAGM,KAHN,EAGayB,UAHb,CAAd;AAKA,UAAMC,gBAAgB,GAAG,CAAClG,CAAC,CAAC1D,EAAE,CAAC6J,SAAH,CAAatG,MAAb,CAAoBG,CAAC,CAACE,MAAF,GAAW,CAAX,CAApB,EAAmC,CAAC,CAApC,CAAD,CAAF,EAA4CF,CAAC,CAACG,KAAF,GAAU,CAAV,CAA5C,CAAzB;AAEA;;;AAGA;;;;;AAIA,aAAS6F,OAAT,GAAmB;AACf1G,MAAAA,OAAO,CAACC,GAAR,CAAY,GAAZ;;AACA,UAAIjD,EAAE,CAAC8J,KAAH,CAASC,SAAb,EAAwB;AACpB,YAAIN,MAAM,GAAGzJ,EAAE,CAAC8J,KAAH,CAASC,SAAtB,CADoB,CAEpB;;AACArG,QAAAA,CAAC,CAACE,MAAF,CAAS,CAAEyF,QAAQ,CAACf,MAAT,CAAgBmB,MAAM,CAAC,CAAD,CAAtB,CAAF,EAA8BJ,QAAQ,CAACf,MAAT,CAAgBmB,MAAM,CAAC,CAAD,CAAtB,CAA9B,CAAT;AACA3F,QAAAA,KAAK,CACG;AACA;AAFH,SAGIC,IAHT,CAGc/D,EAAE,CAACgE,UAAH,CAAcN,CAAd,CAHd;AAIA,YAAIsG,IAAI,GAAGtG,CAAC,CAACvB,aAAa,CAACA,aAAa,CAACQ,MAAd,GAAuB,CAAxB,CAAb,CAAwCH,IAAzC,CAAZ;AACAwH,QAAAA,IAAI,GAAGA,IAAI,GAAG,CAAP,GAAW,CAAX,GAAeA,IAAtB;AACAhH,QAAAA,OAAO,CAACC,GAAR,CAAY+G,IAAZ;AACAhK,QAAAA,EAAE,CACG+B,MADL,CACY,kBADZ,EAEKA,MAFL,CAEY,MAFZ,EAGSG,IAHT,CAGc,OAHd,EAGuBN,KAAK,GAAGoI,IAH/B,EAIS9H,IAJT,CAIc,GAJd,EAImB8H,IAJnB;AAMAlI,QAAAA,GAAG,CACEsD,SADL,CACe,OADf,EAEI;AACA;AAHJ,SAIKlD,IAJL,CAIU,GAJV,EAIeyD,IAJf;AAMA7D,QAAAA,GAAG,CACEC,MADL,CACY,YADZ,EAEKG,IAFL,CAEU,GAFV,EAEe8E,QAFf,EAvBoB,CA2BpB;;AACAlF,QAAAA,GAAG,CACEC,MADL,CACY,aADZ,EAEKG,IAFL,CAEU,GAFV,EAEe8H,IAAI,GAAG,CAACpI,KAAK,GAAGoI,IAAT,IAAiB,CAFvC;AAGAlI,QAAAA,GAAG,CACEC,MADL,CACY,UADZ,EAEKqD,SAFL,CAEe,QAFf,EAGSlD,IAHT,CAGc,IAHd,EAGoB8H,IAHpB;AAIH;AACJ;;AAED,aAASL,UAAT,GAAsB;AAClB,UAAI,CAAC3J,EAAE,CAAC8J,KAAH,CAASC,SAAd,EAAyB;AACrBE,QAAAA,EAAE,CAAClG,IAAH,CAAQwF,KAAK,CAACW,IAAd,EAAoBN,gBAApB;AACH;AAEJ;;AACD,UAAMK,EAAE,GAAGb,OAAO,CACDrF,IADN,CACWwF,KADX,EAEMxF,IAFN,CAEWwF,KAAK,CAACW,IAFjB,EAEuBN,gBAFvB,CAAX,CAvkBU,CA0kBV;;AACA,QAAIO,YAAY,GAAGrD,QAAQ,CAACsD,aAAT,CAAuB,QAAvB,CAAnB;AACAD,IAAAA,YAAY,CAACE,SAAb,GAAyB,OAAzB;;AACAF,IAAAA,YAAY,CAACG,OAAb,GAAuB,MAAM;AACzB,WAAKC,gBAAL,CAAsBlK,QAAtB;AACAU,MAAAA,cAAc,GAAGG,uBAAuB,CAACiC,aAAD,EAAgBE,WAAhB,CAAxC;AACAtC,MAAAA,cAAc,CAAC,CAAD,CAAd,CAAkB2B,KAAlB,GAA0ByE,gBAA1B;AACApG,MAAAA,cAAc,CAAC,CAAD,CAAd,CAAkBgC,OAAlB,GAA4B,IAA5B;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAYlC,cAAZ,EALyB,CAMzB;;AACA,UAAIyJ,QAAQ,GAAGzJ,cAAc,CAACyC,MAAf,CAAsBwD,QAAQ,CAACjE,OAAT,EAAtB,CAAf;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAYuH,QAAZ;AACAvD,MAAAA,QAAQ,CAACf,KAAT,CAAesE,QAAf,EACStI,IADT,CACc,GADd,EACmB8E,QADnB;AAGAlF,MAAAA,GAAG,CACEC,MADL,CACY,sBADZ,EAEKyD,KAFL,CAEW,SAFX,EAEsB,GAFtB;AAGH,KAfD;;AAgBAsB,IAAAA,QAAQ,CAAC2D,aAAT,CAAuB,MAAvB,EAA+BC,WAA/B,CAA2CP,YAA3C;AACH;;AAEDQ,EAAAA,MAAM,GAAG;AACL,wBAAO;AAAK,MAAA,GAAG,EAAE,KAAKrK,QAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAAP;AACH;;AA7mBuC;;AAgnB5C,eAAeL,mBAAf","sourcesContent":["import React, { Component } from 'react';\nimport * as d3 from 'd3';\nimport './UserPredictionChart.css';\n\nclass UserPredictionChart extends Component {\n    constructor(props) {\n        super(props);\n        this.state = { category: \"us_daily_deaths\" };\n        this.chartRef = React.createRef();\n    }\n\n    componentDidMount() {\n        //console.log(this.props);\n        this.renderChart();\n    }\n    renderChart() {\n        const { forecast, orgs, userPrediction, confirmed, aggregate } = this.props;\n        var predictionData = [];//where we will store formatted userPrediction\n        var defaultPredictionData = []\n        const savePrediction = this.savePrediction;\n        const createDefaultPrediction = this.createDefaultPrediction;\n        const category = this.state.category;\n        var compiledData = [];\n        //set up margin, width, height of chart\n        const legendWidth = 180;\n        const toolTipHeight = 50; //to make sure there's room for the tooltip when the value is 0\n        const contextHeight = 100;\n        var margin = {top: 20, right: 30, bottom: 20, left: 60},\n            width = 800 - margin.left - margin.right,\n            height = 400 - margin.top - margin.bottom;\n        var svg = d3.select(this.chartRef.current)\n                    .append(\"svg\")\n                        .attr(\"width\", width + margin.left + margin.right + legendWidth)\n                        .attr(\"height\", height + margin.top + margin.bottom + toolTipHeight + contextHeight)\n                    .append(\"g\")\n                        .attr(\"transform\",\n                        \"translate(\" + margin.left + \",\" + margin.top + \")\");\n        \n        \n        //format confirmedData, forecastData, and predictionData into a list of js objects, convert date from string to js date object\n        var confirmedData = Object.keys(confirmed).map(key => ({\n            date: d3.timeParse(\"%Y-%m-%d\")(key),\n            value: confirmed[key]\n        }));\n\n        //store userPrediction in predictionData if it exists\n        if(Object.keys(userPrediction).length > 0) {\n            predictionData = getMostRecentPrediction(userPrediction).map(p => ({\n                date: d3.timeParse(\"%Y-%m-%d\")((p.date).substring(0,10)),\n                value: p.value,\n                defined: p.defined\n                })\n            );\n        }\n        console.log(predictionData)\n  \n        //set other dates\n        const confirmedStartDate = d3.timeParse(\"%Y-%m-%d\")(\"2020-02-01\"); //date format: y-m-d\n        const predStartDate = confirmedData[confirmedData.length - 1].date; //last date of confirmedData\n        const predLength = 155;\n        //var predEndDateString = addDays(new Date(), predLength).toISOString().substring(0, 10);\n        const predEndDate = d3.timeDay.offset(predStartDate, predLength)\n        \n        //get confirmedData starting from confirmedStartDate\n        confirmedData = confirmedData.filter(d => +d.date >= +confirmedStartDate);\n\n        //draw x-axis     \n        var x = d3.scaleTime()\n            .domain([confirmedStartDate, predEndDate])\n            .range([ 0, width ])\n            //.nice(); //rounds up/down the max and mind of x axis\n        var xAxis = svg\n                        .append(\"g\")\n                        .attr(\"transform\", \"translate(0,\" + height + \")\")\n                        .call(d3.axisBottom(x));\n        \n        //find max val in confirmedData and forecastData to determine the max of y-axis\n        var confirmedMax = d3.max(confirmedData, function(d) { return +d.value; });\n        var forecastMax = 0;\n        forecastData.map(f => {\n            var currMax = d3.max(f, d => {return d.value;})\n            forecastMax = currMax > forecastMax ? currMax : forecastMax;\n        })\n        var yAxisMax = Math.max(confirmedMax, forecastMax);\n        //draw y-axis\n        var y = d3.scaleLinear()\n            .domain([0, yAxisMax])\n            .range([ height, 0 ])\n            .nice();\n        svg\n            .append(\"g\")\n            .call(d3.axisLeft(y));\n   \n        //list of data displayed in graph - for legend\n        var legendString = orgs.concat([\"Daily Confirmed Deaths\", \"Aggregate Forecast\", \"User Prediction\"]);\n        //color function that assigns random colors to each data\n        var color = d3\n                        .scaleOrdinal()\n                        .domain(legendString)\n                        .range(d3.schemeTableau10);\n\n         //draw legend\n        var legend = svg.append('g')\n                        .attr(\"id\", \"legend\")\n        var size = 10;\n        legend.selectAll(\"rect\")\n            .data(legendString)\n            .enter()\n            .append(\"circle\")\n                .attr('cx', width + 30)\n                .attr(\"cy\", function(d,i){ return 20 + i*25}) // 100 is where the first dot appears. 25 is the distance between dots\n                .attr(\"r\", 6)\n                //.attr(\"width\", size)\n                //.attr(\"height\", size)\n                .style(\"fill\", function(d){ return color(d)})\n        legend.selectAll(\"labels\")\n            .data(legendString)\n            .enter()\n            .append(\"text\")\n                .attr(\"x\", width + 45)\n                .attr(\"y\", function(d,i){ return 20 + i*25}) // 100 is where the first dot appears. 25 is the distance between dots\n                .style(\"fill\", function(d){ return color(d)})\n                .text(function(d){ return d})\n                    .attr(\"text-anchor\", \"left\")\n                    .style(\"alignment-baseline\", \"middle\")\n\n        //create line generator for confirmed/forecast data and prediction data\n        var lineGenerator = d3.line()\n            .curve(d3.curveBasis);\n            //.curve(d3.curveCatmullRom)//curve that goes through all data points\n        var predLineGenerator = d3.line()\n            .curve(d3.curveBasis); //curve doesn't go through all data points (it's smoothed out)\n            //d3.curveMonotoneX\n            //d3.curveBasis\n            //d3.curveCardinal\n        \n        //function that draws curve\n        var line = lineGenerator\n            .x(function(d) { return x(d.date) })\n            .y(function(d) { return y(d.value) })\n        \n        //area where the confirmed curve will be drawn\n        var mainClip = svg\n                            .append(\"defs\")\n                            .append(\"svg:clipPath\")\n                                .attr(\"id\", \"main-clip\")\n                                .append(\"svg:rect\")\n                                    .attr(\"width\", width )\n                                    .attr(\"height\", height )\n                                    .attr(\"x\", 0)\n                                    .attr(\"y\", 0);\n\n        // Create the confirmed area variable\n        const mainArea = svg\n                                .append('g')\n                                .attr(\"clip-path\", \"url(#main-clip)\");\n\n        //display confirmed data\n        var confirmedLine = mainArea.append(\"path\")\n                                    .attr(\"id\", \"confirmed\")\n                                    .attr(\"class\", \"line\")    \n                                    .datum(confirmedData)    \n                                    .attr('d', line)\n                                    .attr(\"stroke\", color(legendString[legendString.length - 3]))\n        var confirmedAreaEndX = x(confirmedData[confirmedData.length - 1].date);\n        var confirmedAreaEndY = y(confirmedData[confirmedData.length - 1].value);\n\n        //append clip-path for prediction curve\n        var predictionClip = svg.append(\"defs\").append(\"svg:clipPath\")\n                                .attr(\"id\", \"prediction-clip\")\n                                .append(\"svg:rect\")\n                                    .attr(\"width\", width - confirmedAreaEndX )\n                                    .attr(\"height\", height )\n                                    .attr(\"x\", confirmedAreaEndX)\n                                    .attr(\"y\", 0);\n        const predictionArea = svg.append('g')\n                            .attr(\"clip-path\", \"url(#prediction-clip)\");\n        \n        //make sure aggregateData curve stems from confiremData curve\n        var idxOfStartDate = d3.bisector(f => f.date).left(aggregateData, predStartDate);\n        //check if predStartDate exists in AD\n        if (aggregateData.length > 0 && +aggregateData[idxOfStartDate].date == +predStartDate) {\n            aggregateData[idxOfStartDate].value = confirmedData[confirmedData.length - 1].value;\n        }\n        else {\n            aggregateData.splice(idxOfStartDate, 0, {\n                date: predStartDate,\n                value: confirmedData[confirmedData.length - 1].value\n            });\n            console.log(aggregateData);\n            console.log(\"done\");\n        }\n\n        //display aggregate data\n        var aggregateLine = predictionArea.append(\"path\")\n                                    .attr(\"id\", \"aggregate\")\n                                    .attr(\"class\", \"line\")        \n                                    .datum(aggregateData)    \n                                    .attr('d', line)\n                                    .attr(\"stroke\", color(legendString[legendString.length - 2]))\n        \n        //display forecast data\n        forecastData.map((f, index) => {\n            //make sure they all stem from the confirmed curve!\n            //var temp = d3.timeParse(\"%Y-%m-%d\")(\"2020-07-18\")\n            var idxOfStartDate = d3.bisector(f => f.date).left(f, predStartDate);\n            //check if predStartDate exists in f\n            if (f.length > 0 && +f[idxOfStartDate].date == +predStartDate) {\n                f[idxOfStartDate].value = confirmedData[confirmedData.length - 1].value;\n            }\n            else {\n                f.splice(idxOfStartDate, 0, {\n                    date: predStartDate,\n                    value: confirmedData[confirmedData.length - 1].value\n                });\n                console.log(f);\n                console.log(\"done\");\n            }\n            console.log(f)\n            console.log(idxOfStartDate)\n            predictionArea.append(\"path\")\n                        .attr(\"class\", \"forecast line\")\n                        .attr(\"id\", orgs[index])\n                        .style(\"stroke\", color(orgs[index]))\n                        .datum(f)\n                            .attr(\"d\", line);\n        })\n        \n        var lines = document.getElementsByClassName('line');\n\n        //function that generates the prediction curve\n        var predLine = predLineGenerator\n            .defined(d => d.defined)\n            .x(function(d) { return x(d.date) })\n            .y(function(d) { return y(d.value) })\n\n        //append path for prediction data\n        var yourLine = predictionArea\n                                        .append(\"path\")\n                                        .attr(\"id\", \"your-line\");\n        \n        \n        //variables used to initialize user prediction data if it doesn't exist in the db\n        var currDate = predStartDate;\n        var defined = true;\n        var value = confirmedData[confirmedData.length - 1].value;\n        const confirmedLastVal = value; //used to make sure the first data point of prediction stays the same\n        \n        //check if userPrediction already exists in db\n        if (Object.keys(userPrediction).length > 0) {\n            predictionData = predictionData.filter(d => (+d.date >= +predStartDate) && (+d.date <= +predEndDate));\n            predictionData[0].value = confirmedLastVal;\n            predictionData[0].defined = true;\n            currDate = d3.timeDay.offset(predictionData[predictionData.length - 1].date, 1);\n            //currDate = addDays(predictionData[predictionData.length - 1].date, 1);\n            console.log(predictionData)\n            console.log(createDefaultPrediction(currDate, predEndDate))\n            predictionData.concat(createDefaultPrediction(currDate, predEndDate));\n            console.log(predictionData);\n        }\n        else {\n            predictionData = createDefaultPrediction(predStartDate, predEndDate);\n            predictionData[0].value = confirmedLastVal;\n            predictionData[0].defined = true;\n            console.log(predictionData);\n        }\n\n        var filteredData = null;\n        //var totalData = confirmedData.concat(predictionData);\n\n//!!    //add forecast data to compiledData\n        orgs.map((o, index) => {\n            compiledData.push({\n                name: o,\n                data: forecastData[index]\n            })\n        })\n        compiledData.push({\n            name: \"Daily Confirmed Deaths\",\n            data: confirmedData\n        })\n        compiledData.push({\n            name: \"Aggregate Forecast\",\n            data: aggregateData\n        })\n        //if (userPrediction) {\n        compiledData.push({\n            name: \"User Prediction\",\n            data: predictionData\n        })\n        //}\n        //join data to yourLine\n        filteredData = predictionData.filter(predLine.defined())\n        yourLine.datum(filteredData)\n                .attr('d', predLine)\n                .style(\"stroke\", color(legendString[legendString.length - 1]))\n        //append new rect  \n        const mouseArea = svg.append(\"rect\")\n            .attr(\"width\", width)\n            .attr(\"height\", height)\n            .attr(\"fill\", \"none\")\n            .attr(\"id\", \"mouse-area\")\n            .style(\"pointer-events\",\"visible\");\n\n        //append click area rect\n        var confirmedAreaWidth = confirmedLine.node().getBoundingClientRect().width; //get width of path element containing confirmed data\n        console.log(confirmedAreaWidth)\n        var clickAreaWidth = width - confirmedAreaWidth; //the remaining area\n        svg.append(\"rect\")\n           .attr(\"id\", \"click-area\")\n           .attr(\"width\", clickAreaWidth)\n           .attr(\"height\",height)\n           .attr(\"transform\", \"translate (\" + confirmedAreaWidth+\" 0)\")\n           .attr(\"fill\", \"none\")\n           .style(\"pointer-events\",\"visible\");\n        //var clickArea = d3.select(\"#click-area\");\n        \n        //append draw your guess text\n        const drawingInstruction = svg\n                                        .append(\"g\")\n                                        .attr(\"id\", \"drawing-instruction\")\n                                        .style(\"opacity\", \"0\");\n        drawingInstruction\n                            .append(\"text\")\n                            .attr(\"id\", \"draw-guess\")\n                            .attr(\"x\", confirmedAreaEndX + (width - confirmedAreaEndX) / 2)             \n                            .attr(\"y\", height - 100)\n                            .attr(\"text-anchor\", \"middle\")  \n                            .text(\"Draw your guess\")\n                            .style(\"font-size\", \"16px\");\n        //append circle at the end of confirmed curve\n        var selectCircle = drawingInstruction\n                                                .append(\"g\")\n                                                .attr(\"id\", \"pointer\");\n        var pointerCircles = [\"pulse-disk\", \"pulse-circle\", \"pulse-circle-2\"];\n        pointerCircles.map((c) => {\n        selectCircle.append(\"circle\")\n            .attr(\"class\", c)\n            .attr(\"cx\", confirmedAreaEndX)\n            .attr(\"cy\", confirmedAreaEndY)\n        })\n\n        if(Object.keys(userPrediction).length == 0) {\n            svg\n                .select(\"#drawing-instruction\")\n                .style(\"opacity\", \"1\");\n        }\n\n        var drag = d3.drag()\n                     .on(\"drag\", function() {\n                        //hide \"draw your guess\" text\n                        svg\n                            .select(\"#drawing-instruction\")\n                            .style(\"opacity\", \"0\");\n                        d3.select(\"#tooltip-line\")\n                            .style(\"opacity\", \"0\");\n                        d3.selectAll(\".mouse-per-line circle\")\n                            .style(\"opacity\", \"0\");\n                        d3.selectAll(\".mouse-per-line text\")\n                            .style(\"opacity\", \"0\")\n                        var pos = d3.mouse(this);\n                        var date = clamp(predStartDate, predEndDate, x.invert(pos[0]));\n                        var value = clamp(0, yAxisMax, y.invert(pos[1]));\n                        \n                        predictionData.forEach(function(d){\n                            if (+d3.timeDay.round(d.date) == +d3.timeDay.round(date)){\n                                d.value = value;\n                                d.defined = true\n                            }\n                        predictionData[0].value = confirmedLastVal;//make sure the prediction curve is always connected to the confirmed curve\n                        //update totalData everytime predictionData is updated\n                        compiledData[compiledData.length - 1].data = predictionData;\n                        //console.log(compiledData)\n                        /*yourLine.datum(predictionData)\n                                .attr('d', predLine)*/\n                        var filteredData = predictionData.filter(predLine.defined())\n\n                        yourLine.datum(filteredData)\n                                .attr('d', predLine)\n                                .style(\"stroke\", color(legendString[legendString.length - 1]))\n\n                        });\n                    })\n                    .on(\"end\", function () {\n                        savePrediction(predictionData, category);\n                        d3.select(\"#tooltip-line\")\n                            .style(\"opacity\", \"1\");\n                        d3.selectAll(\".mouse-per-line circle\")\n                            .style(\"opacity\", \"1\");\n                        d3.selectAll(\".mouse-per-line text\")\n                            .style(\"opacity\", \"1\")\n                    });\n        \n        svg.call(drag)\n\n        //finds the datapoint closest to the mouse (along x)\n        /*var bisect = () => {\n            const bisectDate = d3.bisector(d => d.date).left;\n            return mx => {\n                const date = x.invert(mx);\n                const index = bisectDate(totalData, date, 1);\n                const a = totalData[index - 1];\n                const b = totalData[index];\n                return b && (date - a.date > b.date - date) ? b : a;\n            };\n        }*/\n\n\n        const tooltipArea = svg\n                                .append(\"g\")\n                                .attr(\"class\", \"tooltip\")\n\n        tooltipArea.append(\"path\") //vertical line\n                    .attr(\"id\", \"tooltip-line\")\n                    .style(\"stroke\", \"black\")\n                    .style(\"stroke-width\", \"0.5px\")\n                    .style(\"opacity\", \"0\");\n        \n        var mousePerLine = tooltipArea\n                                        .selectAll(\".mouse-per-line\")\n                                        .data(compiledData)\n                                        .enter()\n                                        .append(\"g\")\n                                        .attr(\"class\", \"mouse-per-line\");\n        \n        mousePerLine.append(\"circle\")\n                        .attr(\"r\", 2)\n                        .style(\"stroke\", function(d) {\n                            return color(d.name);\n                        })\n                        .style(\"fill\", \"none\")\n                        .style(\"stroke-width\", \"1px\")\n                        .style(\"opacity\", \"0\");\n        mousePerLine.append(\"text\")\n                    .attr(\"transform\", \"translate(10,3)\"); \n        tooltipArea\n                    .append(\"svg:rect\")\n                    .attr('width', width)\n                    .attr('height', height)\n                    .attr('fill', 'none')\n                    .attr('pointer-events', 'all')\n                    .style(\"cursor\", \"pointer\")\n                    .on('mouseout', function() { // on mouse out hide line, circles and text\n                        d3.select(\"#tooltip-line\")\n                          .style(\"opacity\", \"0\");\n                        d3.selectAll(\".mouse-per-line circle\")\n                          .style(\"opacity\", \"0\");\n                        d3.selectAll(\".mouse-per-line text\")\n                          .style(\"opacity\", \"0\")\n                    })\n                    .on('mouseover', function() { // on mouse in show line, circles and text\n                        d3.select(\"#tooltip-line\")\n                          .style(\"opacity\", \"1\");\n                        d3.selectAll(\".mouse-per-line circle\")\n                          .style(\"opacity\", \"1\");\n                        d3.selectAll(\".mouse-per-line text\")\n                          .style(\"opacity\", \"1\")\n\n                    })\n                    .on('mousemove', function() { // mouse moving over canvas\n                        var mouse = d3.mouse(this);\n                        var xCoord = mouse[0];\n                        d3\n                            .select(\"#tooltip-line\")\n                            .attr(\"d\", function() {\n                                var d = \"M\" + xCoord + \",\" + height;\n                                d += \" \" + xCoord + \",\" + 0;\n                                return d;\n                            });\n                        d3\n                            .selectAll(\".mouse-per-line\")\n                            .attr(\"transform\", function(d, i) {\n                                if (d.data.length == 0) {return;}\n                                var date = x.invert(xCoord);\n                                const index = d3.bisector(f => f.date).left(compiledData[i].data, date);\n                                var a = null;\n                                if (index > 0) {\n                                    a = d.data[index - 1];\n                                }\n                                const b = d.data[index];\n                                //d = the data object corresponding to date and value pointed by the cursors\n                                var data = null;\n                                if (!a) {\n                                    data = b;\n                                }\n                                else if (!b) {\n                                    data = a;\n                                }\n                                else {\n                                    data = b && (date - a.date > b.date - date) ? b : a;\n                                }\n                                if (+d3.timeDay.floor(date) == +data.date || +d3.timeDay.ceil(date) == +data.date) {\n                                    if (data.defined != 0) {\n                                        var element = d3.select(this)\n                                                        .select('text')\n                                                            .style(\"opacity\", \"1\")\n                                                            .text(Math.round(data.value).toFixed(2));\n                                        element.select(\"circle\")\n                                                .style(\"opacity\", \"1\");\n                                        return \"translate(\" + mouse[0] + \",\" + y(data.value)+\")\";\n                                    }\n                                }\n                                var element = d3.select(this)\n                                                .select(\"text\")\n                                                .style(\"opacity\", \"0\")\n                                element\n                                        .select(\"circle\")\n                                        .style(\"opacity\", \"0\");\n                                \n                        });\n                    })\n\n        /////////////////////////////////////////////////////////////////////////////////////////////\n        const focusHeight = 100;\n        const contextMargin = 50;\n        var context = svg\n                            .append(\"g\")\n                                .attr(\"viewBox\", [0, 0, width, focusHeight])\n                                .attr(\"transform\", `translate(0,${height + contextMargin} )`)\n                                //.attr(\"width\", width + 100)\n                                //.attr(\"height\", height)\n                                .style(\"display\", \"block\")\n\n\n\n        /*const xAxis = (g, x, height) => g\n                                            .attr(\"transform\", `translate(0,${height - margin.bottom})`)\n                                            .call(d3.axisBottom(x))*/\n\n        var contextX = d3\n                            .scaleTime()\n                            .domain([confirmedStartDate, predEndDate])\n                            .range([0, width]);\n        \n        var contextXAxis = context\n                                    .append(\"g\")\n                                    .attr(\"transform\", `translate(0,${focusHeight - margin.bottom})`)\n                                    .call(d3.axisBottom(contextX));\n        const brush = d3.brushX()\n                        .extent([[0, 0], [width, focusHeight - margin.bottom]])\n                        .on(\"brush\", brushed)\n                        .on(\"end\", brushended);\n\n        const defaultSelection = [x(d3.timeMonth.offset(x.domain()[1], -8)), x.range()[1]];\n    \n        /*context.append(\"g\")\n                .call(xAxis, x, focusHeight);*/\n    \n        /*svg.append(\"path\")\n            .datum(confirmedData)\n            .attr(\"fill\", \"steelblue\")\n            .attr(\"d\", line(x, y.copy().range([focusHeight - margin.bottom, 4])));*/\n        function brushed() {\n            console.log(\"d\")\n            if (d3.event.selection) {\n                var extent = d3.event.selection;\n                //console.log([ contextX.invert(extent[0]), contextX.invert(extent[1]) ]);\n                x.domain([ contextX.invert(extent[0]), contextX.invert(extent[1]) ]);\n                xAxis\n                        //.transition()\n                        //.duration(1000)\n                        .call(d3.axisBottom(x))\n                var newX = x(confirmedData[confirmedData.length - 1].date);\n                newX = newX < 0 ? 0 : newX;\n                console.log(newX);\n                d3\n                    .select(\"#prediction-clip\")\n                    .select(\"rect\")\n                        .attr(\"width\", width - newX)\n                        .attr(\"x\", newX);\n\n                svg\n                    .selectAll(\".line\")\n                    //.transition()\n                    //.duration(1000)\n                    .attr('d', line)\n\n                svg\n                    .select(\"#your-line\")\n                    .attr(\"d\", predLine)\n                \n                //reposition draw your guess text and pointer\n                svg\n                    .select(\"#draw-guess\")\n                    .attr(\"x\", newX + (width - newX) / 2);\n                svg\n                    .select(\"#pointer\")\n                    .selectAll(\"circle\")\n                        .attr(\"cx\", newX);\n            }\n        }\n        \n        function brushended() {\n            if (!d3.event.selection) {\n                gb.call(brush.move, defaultSelection);\n            }\n\n        }\n        const gb = context\n                        .call(brush)\n                        .call(brush.move, defaultSelection);   \n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        var deleteButton = document.createElement(\"button\")\n        deleteButton.innerText = \"Reset\";\n        deleteButton.onclick = () => {\n            this.deletePrediction(category)\n            predictionData = createDefaultPrediction(predStartDate, predEndDate);\n            predictionData[0].value = confirmedLastVal;\n            predictionData[0].defined = true;\n            console.log(predictionData)\n            //update yourLine\n            var filtered = predictionData.filter(predLine.defined())\n            console.log(filtered)\n            yourLine.datum(filtered)\n                    .attr('d', predLine)\n                    \n            svg\n                .select(\"#drawing-instruction\")\n                .style(\"opacity\", \"1\");\n        };\n        document.querySelector(\"body\").appendChild(deleteButton);\n    }\n\n    render() {\n        return(<div ref={this.chartRef}></div>);\n    }\n}\n\nexport default UserPredictionChart;\n"]},"metadata":{},"sourceType":"module"}