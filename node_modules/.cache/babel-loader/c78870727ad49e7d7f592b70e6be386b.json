{"ast":null,"code":"var _jsxFileName = \"/Users/sarah/Documents/Sarah/Projects/reu/covid19-forecasting-market/frontend/src/components/UserPredictionChart/index.js\";\nimport React, { Component } from 'react';\nimport * as d3 from 'd3';\nimport './UserPredictionChart.css';\nimport { getMostRecentPrediction, sortDictByDate } from '../../utils/data';\n\nclass UserPredictionChart extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      category: \"us_daily_deaths\"\n    };\n    this.chartRef = React.createRef();\n  }\n\n  componentDidMount() {\n    //console.log(this.props);\n    this.renderChart();\n  }\n\n  renderChart() {\n    const {\n      forecast,\n      orgs,\n      userPrediction,\n      confirmed,\n      aggregate\n    } = this.props;\n    var predictionData = {}; //where we will store formatted userPrediction\n\n    var defaultPredictionData = [];\n    const savePrediction = this.savePrediction;\n    const createDefaultPrediction = this.createDefaultPrediction;\n    const category = this.state.category;\n    var compiledData = []; //set up margin, width, height of chart\n\n    const legendWidth = 180;\n    const toolTipHeight = 50; //to make sure there's room for the tooltip when the value is 0\n\n    const contextHeight = 100;\n    var margin = {\n      top: 20,\n      right: 30,\n      bottom: 20,\n      left: 60\n    },\n        width = 800 - margin.left - margin.right,\n        height = 400 - margin.top - margin.bottom;\n    var svg = d3.select(this.chartRef.current).append(\"svg\").attr(\"width\", width + margin.left + margin.right + legendWidth).attr(\"height\", height + margin.top + margin.bottom + toolTipHeight + contextHeight).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\"); //format confirmedData, forecastData, and predictionData into a list of js objects, convert date from string to js date object\n\n    var confirmedData = Object.keys(confirmed).map(key => ({\n      date: d3.timeParse(\"%Y-%m-%d\")(key),\n      value: confirmed[key]\n    })); //store userPrediction in predictionData if it exists; parse dates and store as d3 date objects\n\n    if (Object.keys(userPrediction).length > 0) {\n      Object.keys(userPrediction).map(p => {\n        predictionData[p] = userPrediction[p].map(d => ({\n          date: d3.timeParse(\"%Y-%m-%d\")(d.date.substring(0, 10)),\n          value: d.value,\n          defined: d.defined\n        }));\n      });\n    }\n\n    predictionData = sortDictByDate(predictionData);\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: this.chartRef,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 62,\n        columnNumber: 16\n      }\n    });\n  }\n\n}\n\nexport default UserPredictionChart;","map":{"version":3,"sources":["/Users/sarah/Documents/Sarah/Projects/reu/covid19-forecasting-market/frontend/src/components/UserPredictionChart/index.js"],"names":["React","Component","d3","getMostRecentPrediction","sortDictByDate","UserPredictionChart","constructor","props","state","category","chartRef","createRef","componentDidMount","renderChart","forecast","orgs","userPrediction","confirmed","aggregate","predictionData","defaultPredictionData","savePrediction","createDefaultPrediction","compiledData","legendWidth","toolTipHeight","contextHeight","margin","top","right","bottom","left","width","height","svg","select","current","append","attr","confirmedData","Object","keys","map","key","date","timeParse","value","length","p","d","substring","defined","render"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport * as d3 from 'd3';\nimport './UserPredictionChart.css';\nimport { getMostRecentPrediction, sortDictByDate } from '../../utils/data';\n\nclass UserPredictionChart extends Component {\n    constructor(props) {\n        super(props);\n        this.state = { category: \"us_daily_deaths\" };\n        this.chartRef = React.createRef();\n    }\n\n    componentDidMount() {\n        //console.log(this.props);\n        this.renderChart();\n    }\n    renderChart() {\n        const { forecast, orgs, userPrediction, confirmed, aggregate } = this.props;\n        var predictionData = {};//where we will store formatted userPrediction\n        var defaultPredictionData = []\n        const savePrediction = this.savePrediction;\n        const createDefaultPrediction = this.createDefaultPrediction;\n        const category = this.state.category;\n        var compiledData = [];\n        //set up margin, width, height of chart\n        const legendWidth = 180;\n        const toolTipHeight = 50; //to make sure there's room for the tooltip when the value is 0\n        const contextHeight = 100;\n        var margin = {top: 20, right: 30, bottom: 20, left: 60},\n            width = 800 - margin.left - margin.right,\n            height = 400 - margin.top - margin.bottom;\n        var svg = d3.select(this.chartRef.current)\n                    .append(\"svg\")\n                        .attr(\"width\", width + margin.left + margin.right + legendWidth)\n                        .attr(\"height\", height + margin.top + margin.bottom + toolTipHeight + contextHeight)\n                    .append(\"g\")\n                        .attr(\"transform\",\n                        \"translate(\" + margin.left + \",\" + margin.top + \")\");\n        \n        \n        //format confirmedData, forecastData, and predictionData into a list of js objects, convert date from string to js date object\n        var confirmedData = Object.keys(confirmed).map(key => ({\n            date: d3.timeParse(\"%Y-%m-%d\")(key),\n            value: confirmed[key]\n        }));\n\n        //store userPrediction in predictionData if it exists; parse dates and store as d3 date objects\n        if(Object.keys(userPrediction).length > 0) {\n            Object.keys(userPrediction).map(p => {\n                predictionData[p]= userPrediction[p].map(d => ({\n                    date: d3.timeParse(\"%Y-%m-%d\")((d.date).substring(0,10)),\n                    value: d.value,\n                    defined: d.defined\n                }))\n            })\n        }\n        predictionData = sortDictByDate(predictionData)\n\n    }\n\n    render() {\n        return(<div ref={this.chartRef}></div>);\n    }\n}\n\nexport default UserPredictionChart;\n"]},"metadata":{},"sourceType":"module"}